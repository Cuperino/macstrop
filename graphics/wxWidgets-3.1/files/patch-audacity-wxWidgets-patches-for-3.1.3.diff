From 83e466d9af94ba64d090fe16817dfe661cf7df88 Mon Sep 17 00:00:00 2001
From: James Crook <james.k.crook@gmail.com>
Date: Thu, 29 Dec 2016 17:37:47 +0000
Subject: [PATCH 01/25] Windows: Accessibility/Setup patch applied.

Note that the patch in Audacity/win/wxWidgets_additions/accessibility.diff patches setup.h
This patch applied here patches setup0.h, which will become setup.h.
(There is no setup.h in the git repo).
===
 include/wx/msw/setup0.h | 19 +++++++------------
 1 file changed, 7 insertions(+), 12 deletions(-)

diff --git include/wx/msw/setup0.h include/wx/msw/setup0.h
index 1d1890f6cbe..e0e972b6148 100644
--- include/wx/msw/setup0.h
+++ include/wx/msw/setup0.h
@@ -87,11 +87,12 @@
 // NDEBUG) or, on the contrary, enable more asserts, including the usually
 // disabled ones, in the debug build (then do it inside #ifndef NDEBUG)
 //
-// #ifdef NDEBUG
-//  #define wxDEBUG_LEVEL 0
-// #else
-//  #define wxDEBUG_LEVEL 2
-// #endif
+// Uncommented for Audacity, and set to 1 (rather than 2) for debug builds.
+#ifdef NDEBUG
+  #define wxDEBUG_LEVEL 0
+#else
+  #define wxDEBUG_LEVEL 1
+#endif
 
 // wxHandleFatalExceptions() may be used to catch the program faults at run
 // time and, instead of terminating the program with a usual GPF message box,
@@ -1407,14 +1408,8 @@
 // Use wxAccessible for enhanced and customisable accessibility.
 // Depends on wxUSE_OLE on MSW.
 //
-// Default is 1 on MSW, 0 elsewhere.
-//
-// Recommended setting (at present): 1 (MSW-only)
-#ifdef __WXMSW__
+// Set to 1 for Audacity
 #define wxUSE_ACCESSIBILITY 1
-#else
-#define wxUSE_ACCESSIBILITY 0
-#endif
 
 // ----------------------------------------------------------------------------
 // miscellaneous settings

From 5d526180f3879e54823fd88b95efb98515ad7266 Mon Sep 17 00:00:00 2001
From: Paul Licameli <paul.licameli@audacityteam.org>
Date: Wed, 6 Jul 2016 14:18:17 -0400
Subject: [PATCH 02/25] Focus rings are back for buttons, choice, listbox,
 dateTimePicker controls

---
 include/wx/button.h       |  4 ++++
 include/wx/choice.h       |  4 ++++
 include/wx/datetimectrl.h |  3 +++
 include/wx/listbox.h      |  4 +++-
 include/wx/window.h       |  4 +++-
 src/osx/cocoa/window.mm   | 33 +++++++++++++++++++++++++++++----
 6 files changed, 46 insertions(+), 6 deletions(-)

diff --git include/wx/button.h include/wx/button.h
index 0f26c65b0c3..e5d2fd5e54a 100644
--- include/wx/button.h
+++ include/wx/button.h
@@ -43,6 +43,10 @@ class WXDLLIMPEXP_CORE wxButtonBase : public wxAnyButton
     // specific window when the platform supports per-monitor DPI
     static wxSize GetDefaultSize(wxWindow* win = NULL);
 
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const wxOVERRIDE { return true; }
+#endif
+
 protected:
     wxDECLARE_NO_COPY_CLASS(wxButtonBase);
 };
diff --git include/wx/choice.h include/wx/choice.h
index b5bfac3b1a1..8e014a6677a 100644
--- include/wx/choice.h
+++ include/wx/choice.h
@@ -57,6 +57,10 @@ class WXDLLIMPEXP_CORE wxChoiceBase : public wxControlWithItems
     // override wxItemContainer::IsSorted
     virtual bool IsSorted() const wxOVERRIDE { return HasFlag(wxCB_SORT); }
 
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const wxOVERRIDE { return true; }
+#endif
+
 protected:
     // The generic implementation doesn't determine the height correctly and
     // doesn't account for the width of the arrow but does take into account
diff --git include/wx/datetimectrl.h include/wx/datetimectrl.h
index 30f23dfffe0..441cf945bf0 100644
--- include/wx/datetimectrl.h
+++ include/wx/datetimectrl.h
@@ -32,6 +32,9 @@ class WXDLLIMPEXP_ADV wxDateTimePickerCtrlBase : public wxControl
     // Set/get the date or time (in the latter case, time part is ignored).
     virtual void SetValue(const wxDateTime& dt) = 0;
     virtual wxDateTime GetValue() const = 0;
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const wxOVERRIDE { return true; }
+#endif
 };
 
 #if defined(__WXMSW__) && !defined(__WXUNIVERSAL__)
diff --git include/wx/listbox.h include/wx/listbox.h
index 69525e219f8..6e1c53b5d10 100644
--- include/wx/listbox.h
+++ include/wx/listbox.h
@@ -96,7 +96,9 @@ class WXDLLIMPEXP_CORE wxListBoxBase : public wxControlWithItems
     // return the index of the item at this position or wxNOT_FOUND
     int HitTest(const wxPoint& point) const { return DoListHitTest(point); }
     int HitTest(int x, int y) const { return DoListHitTest(wxPoint(x, y)); }
-
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const wxOVERRIDE { return true; }
+#endif
 
 protected:
     virtual void DoSetFirstItem(int n) = 0;
diff --git include/wx/window.h include/wx/window.h
index c08ffa77127..2bb92309ae4 100644
--- include/wx/window.h
+++ include/wx/window.h
@@ -252,7 +252,9 @@ class WXDLLIMPEXP_CORE wxWindowBase : public wxEvtHandler
 
     // moving/resizing
     // ---------------
-
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const { return false; }
+#endif
         // set the window size and/or position
     void SetSize( int x, int y, int width, int height,
                   int sizeFlags = wxSIZE_AUTO )
diff --git src/osx/cocoa/window.mm src/osx/cocoa/window.mm
index 6f570d531ec30f51d84fe94ac3aeaf2b4cce340e..e0a0206fb4d1eab15eadd16b8d944e94d9898c91 100644
--- src/osx/cocoa/window.mm
+++ src/osx/cocoa/window.mm
@@ -17,7 +17,9 @@
     #include "wx/textctrl.h"
     #include "wx/combobox.h"
     #include "wx/radiobut.h"
+    #include "wx/button.h"
 #endif
+#include "wx/hashset.h"
 
 #ifdef __WXMAC__
     #include "wx/osx/private.h"
@@ -39,6 +41,7 @@
 #endif
 
 #include <objc/objc-runtime.h>
+#include "wx/string.h"
 
 // Get the window with the focus
 
@@ -95,12 +98,12 @@ WXWidget wxWidgetImpl::FindFocus()
 wxWidgetImpl* wxWidgetImpl::FindBestFromWXWidget(WXWidget control)
 {
     wxWidgetImpl* impl = FindFromWXWidget(control);
-    
+
     // NSScrollViews can have their subviews like NSClipView
     // therefore check and use the NSScrollView peer in that case
     if ( impl == NULL && [[control superview] isKindOfClass:[NSScrollView class]])
         impl = FindFromWXWidget([control superview]);
-    
+
     return impl;
 }
 
@@ -118,11 +121,11 @@ NSRect wxOSXGetFrameForControl( wxWindowMac* window , const wxPoint& pos , const
 
 @interface wxNSView : NSView
 {
-    BOOL _hasToolTip;    
+    BOOL _hasToolTip;
     NSTrackingRectTag   _lastToolTipTrackTag;
     id              _lastToolTipOwner;
     void*           _lastUserData;
-    
+
 }
 
 @end // wxNSView
@@ -213,7 +216,7 @@ NSRect wxOSXGetFrameForControl( wxWindowMac* window , const wxPoint& pos , const
         const UniCharCount maxStringLength = 255;
         UniCharCount actualStringLength = 0;
         UniChar unicodeString[maxStringLength];
-        
+
         OSStatus status = UCKeyTranslate(keyboardLayout,
                                          [self keyCode],
                                          kUCKeyActionDown,
@@ -224,7 +227,7 @@ NSRect wxOSXGetFrameForControl( wxWindowMac* window , const wxPoint& pos , const
                                          maxStringLength,
                                          &actualStringLength,
                                          unicodeString);
-        
+
         if(status == noErr)
             result = [NSString stringWithCharacters:unicodeString length:(NSInteger)actualStringLength];
     }
@@ -347,7 +350,7 @@ long wxOSXTranslateCocoaKey( NSEvent* event, int eventType )
         default:
             break;
     }
-    
+
     // Check for NUMPAD keys.  For KEY_UP/DOWN events we need to use the
     // WXK_NUMPAD constants, but for the CHAR event we want to use the
     // standard ascii values
@@ -516,7 +519,7 @@ void wxWidgetCocoaImpl::SetupKeyEvent(wxKeyEvent &wxevent , NSEvent * nsEvent, N
 UInt32 g_lastButton = 0 ;
 bool g_lastButtonWasFakeRight = false ;
 
-// better scroll wheel support 
+// better scroll wheel support
 // see http://lists.apple.com/archives/cocoa-dev/2007/Feb/msg00050.html
 
 @interface NSEvent (DeviceDelta)
@@ -534,20 +537,20 @@ wxSetupCoordinates(NSView* view, wxCoord &x, wxCoord &y, NSEvent* nsEvent)
 {
     NSRect locationInWindow = NSZeroRect;
     locationInWindow.origin = [nsEvent locationInWindow];
-    
+
     // adjust coordinates for the window of the target view
     if ( [nsEvent window] != [view window] )
     {
         if ( [nsEvent window] != nil )
             locationInWindow = [[nsEvent window] convertRectToScreen:locationInWindow];
-        
+
         if ( [view window] != nil )
             locationInWindow = [[view window] convertRectFromScreen:locationInWindow];
     }
-    
+
     NSPoint locationInView = [view convertPoint:locationInWindow.origin fromView:nil];
     wxPoint locationInViewWX = wxFromNSPoint( view, locationInView );
-        
+
     x = locationInViewWX.x;
     y = locationInViewWX.y;
 
@@ -562,7 +565,7 @@ void wxWidgetCocoaImpl::SetupMouseEvent( wxMouseEvent &wxevent , NSEvent * nsEve
 {
     int eventType = [nsEvent type];
     UInt32 modifiers = [nsEvent modifierFlags] ;
-    
+
     SetupCoordinates(wxevent.m_x, wxevent.m_y, nsEvent);
 
     // these parameters are not given for all events
@@ -718,7 +721,7 @@ void wxWidgetCocoaImpl::SetupMouseEvent( wxMouseEvent &wxevent , NSEvent * nsEve
                 deltaX = [nsEvent scrollingDeltaX] * 10;
                 deltaY = [nsEvent scrollingDeltaY] * 10;
             }
-            
+
             wxevent.m_wheelDelta = 10;
             wxevent.m_wheelInverted = [nsEvent isDirectionInvertedFromDevice];
             wxevent.m_linesPerAction = 1;
@@ -752,12 +755,12 @@ void wxWidgetCocoaImpl::SetupMouseEvent( wxMouseEvent &wxevent , NSEvent * nsEve
         case NSMouseMoved :
             wxevent.SetEventType( wxEVT_MOTION ) ;
             break;
-        
+
         case NSEventTypeMagnify:
             wxevent.SetEventType( wxEVT_MAGNIFY );
             wxevent.m_magnification = [nsEvent magnification];
             break;
-            
+
         default :
             break ;
     }
@@ -807,7 +810,7 @@ static void SetDrawingEnabledIfFrozenRecursive(wxWidgetCocoaImpl *impl, bool ena
     }
 }
 
-/* idea taken from webkit sources: overwrite the methods that (private) NSToolTipManager will use to attach its tracking rectangle 
+/* idea taken from webkit sources: overwrite the methods that (private) NSToolTipManager will use to attach its tracking rectangle
  * then when changing the tooltip send fake view-exit and view-enter methods which will lead to a tooltip refresh
  */
 
@@ -855,7 +858,7 @@ static void SetDrawingEnabledIfFrozenRecursive(wxWidgetCocoaImpl *impl, bool ena
         _hasToolTip = YES;
         [self _sendToolTipMouseEntered];
     }
-    else 
+    else
     {
         if ( _hasToolTip )
         {
@@ -880,7 +883,7 @@ static void SetDrawingEnabledIfFrozenRecursive(wxWidgetCocoaImpl *impl, bool ena
 
 - (void)removeTrackingRect:(NSTrackingRectTag)tag
 {
-    if (tag == _lastToolTipTrackTag) 
+    if (tag == _lastToolTipTrackTag)
     {
         _lastUserData = NULL;
         _lastToolTipOwner = nil;
@@ -964,7 +967,7 @@ void wxOSX_insertText(NSView* self, SEL _cmd, NSString* text);
 }
 
 - (NSRange)selectedRange
-{    
+{
     return NSMakeRange(NSNotFound, 0);
 }
 
@@ -1000,6 +1003,22 @@ void wxOSX_insertText(NSView* self, SEL _cmd, NSString* text);
 @end // wxNSView(TextInput)
 
 
+// An objective-C object that can be returned to Cocoa to receive the
+// callbacks for accessibility, in case its parent defines it as an accessible
+// sub-element that does not correspond to an entire wxWindow.
+@interface wxAccessibilityChild : NSObject
+{
+   wxAccessible *accessible;
+   NSInteger number;
+}
+
+- (id)initWithAccessible: (wxAccessible*)accessible_
+               andNumber: (NSInteger)number_;
+
++ (id)accessibilityChildWithAccessible: (wxAccessible*)accessible_
+                             andNumber: (NSInteger)number_;
+@end
+
 //
 // event handlers
 //
@@ -1045,8 +1064,1410 @@ BOOL wxOSX_performDragOperation( id self, SEL _cmd, id <NSDraggingInfo> sender )
     return impl->performDragOperation(sender, self, _cmd) ? YES:NO ;
 }
 
+namespace {
+   wxAccessible *findAccessible( id view )
+   {
+      wxWidgetCocoaImpl* impl;
+      wxWindow* win;
+      wxAccessible *accessible;
+
+      if ((impl =
+           (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( view )) &&
+          (win = impl->GetWXPeer()) &&
+          (accessible = win->GetAccessible()))
+         return accessible;
+
+      return NULL;
+   }
+
+   id GetUIElement
+   (wxAccessible &accessible, int childID = wxACC_SELF,
+    wxAccessible *pChild = NULL)
+   {
+      if (pChild)
+         return pChild->GetWindow()->GetPeer()->GetWXWidget();
+      else
+         return
+         [wxAccessibilityChild accessibilityChildWithAccessible: &accessible
+                                                      andNumber: childID];
+   }
+
+   struct wxNSAccessibilityAttribute
+   {
+      explicit
+      wxNSAccessibilityAttribute(NSString *name_, bool dummy = false);
+
+      struct Hash
+      {
+         size_t operator()( const void* k ) const
+         {
+            return
+               [static_cast<const wxNSAccessibilityAttribute*>(k)->name hash];
+         }
+      };
+
+      struct Equal
+      {
+         bool operator()( const void* a, const void* b ) const
+         {
+            return
+               [static_cast<const wxNSAccessibilityAttribute*>(a)->name
+                isEqual:
+                static_cast<const wxNSAccessibilityAttribute*>(b)->name];
+         }
+      };
+
+      void RaiseException(id element, id value = nil) const
+      {
+         NSAccessibilityRaiseBadArgumentException(element, name, value);
+      }
+
+      virtual bool IsPresent
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         return false;
+      }
+
+      virtual bool IsSettable
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         return false;
+      }
+
+      virtual id Get
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         RaiseException(element);
+         return nil;
+      }
+
+      virtual void Set
+         (id element, wxAccessible &accessible, int childID, id value) const
+      {
+         RaiseException(element, value);
+      }
+
+      NSString *const name;
+   };
+
+   WX_DECLARE_HASH_SET(
+      wxNSAccessibilityAttribute*,
+      wxNSAccessibilityAttribute::Hash,
+      wxNSAccessibilityAttribute::Equal,
+      AllAttributes
+   );
+
+   AllAttributes sAllAttributes;
+
+   wxNSAccessibilityAttribute::wxNSAccessibilityAttribute
+      (NSString *name_, bool dummy)
+   : name (name_)
+   {
+      if (!dummy)
+         sAllAttributes.insert(this);
+   }
+
+   const wxNSAccessibilityAttribute *findAttribute(id element, NSString *name)
+   {
+      wxNSAccessibilityAttribute attr(name, true);
+      AllAttributes::const_iterator it = sAllAttributes.find(&attr);
+      if (it != sAllAttributes.end())
+         return *it;
+      return NULL;
+   }
+
+   NSArray *findAttributeNames
+   ( id self, wxAccessible &accessible, int childId,
+    NSArray *otherAttributes )
+   {
+      NSMutableArray *result =
+      otherAttributes
+      ? [NSMutableArray arrayWithArray: otherAttributes]
+      : [NSMutableArray arrayWithCapacity: sAllAttributes.size()];
+      AllAttributes::const_iterator it = sAllAttributes.begin(),
+      end = sAllAttributes.end();
+      for (; it != end; ++it)
+      {
+         const wxNSAccessibilityAttribute &attribute = **it;
+         if (attribute.IsPresent(self, accessible, childId)) {
+            NSString *name = attribute.name;
+            if (otherAttributes && [otherAttributes containsObject: name])
+               // don't duplicate
+               continue;
+            [result addObject: name];
+         }
+      }
+      return result;
+   }
+
+   // Useful, still abstract, subclass of wxNSAccessibilityAttribute
+   // helps to implement other parts of the protocol that query only the
+   // size or a sub-range of the arrays.
+   struct wxNSAccessibilityArrayAttribute : wxNSAccessibilityAttribute
+   {
+      explicit
+      wxNSAccessibilityArrayAttribute(NSString *name)
+      : wxNSAccessibilityAttribute(name)
+      {}
+
+      virtual unsigned GetCount
+      (id element, wxAccessible &accessible, int childID) const = 0;
+
+      virtual id GetArrayElement
+      (id element, wxAccessible &accessible, int childID,
+       unsigned index) const = 0;
+
+      NSUInteger IndexOfValue
+      (id element, wxAccessible &accessible, int childID, id value) const
+      {
+         unsigned count = GetCount(element, accessible, childID);
+         for (unsigned index = 0; index < count; ++index)
+         {
+            id arrayElement =
+            GetArrayElement(element, accessible, childID, index);
+            if ([value isEqual: arrayElement])
+               return index;
+         }
+         return NSNotFound;
+      }
+
+      id GetValues
+      (id element, wxAccessible &accessible, int childID,
+       unsigned index, unsigned maxCount) const
+      {
+         if (maxCount == 0)
+            return [NSArray array];
+
+         NSMutableArray *result =
+         [NSMutableArray arrayWithCapacity: (NSUInteger)maxCount];
+
+         unsigned limit = index + maxCount;
+         while (index < limit)
+         {
+            id arrayElement =
+            GetArrayElement(element, accessible, childID, index);
+            if (arrayElement)
+               [result addObject: arrayElement];
+            ++index;
+         }
+         return result;
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         unsigned count = GetCount(element, accessible, childID);
+         return GetValues(element, accessible, childID, 0, count);
+      }
+   };
+
+   struct wxNAccessibilityStringAttribute : wxNSAccessibilityAttribute
+   {
+      typedef wxAccStatus (wxAccessible::*PMF)(int, wxString*);
+
+      wxNAccessibilityStringAttribute(NSString *name_, PMF pmf_)
+      : wxNSAccessibilityAttribute(name_)
+      , pmf(pmf_)
+      {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxString str;
+         return (wxACC_OK == (accessible.*pmf)(childID, &str));
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxString result;
+         if (wxACC_OK == (accessible.*pmf)(childID, &result))
+            return (id) wxNSStringWithWxString(result);
+         else
+            return @"";
+      }
+
+      const PMF pmf;
+   };
+
+   template <
+      unsigned long StateFlag, bool StateFlagState,
+      unsigned long SettableFlag, bool SettableFlagState,
+      wxAccSelectionFlags SelectFlag
+   > struct wxNSAccessibilityStateAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityStateAttribute(NSString *name)
+      : wxNSAccessibilityAttribute(name)
+      {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id Get
+      (id, wxAccessible &accessible, int childID) const
+      {
+         BOOL result = NO;
+         long state = 0;
+         wxAccStatus status = accessible.GetState(childID, &state);
+         if (wxACC_OK == status &&
+             StateFlagState == !!(state & StateFlag))
+            result = YES;
+         return [NSNumber numberWithBool: result];
+      }
+
+      virtual bool IsSettable
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         long state = 0;
+         wxAccStatus status = accessible.GetState(childID, &state);
+         return
+         (wxACC_OK == status &&
+          SettableFlagState == !!(state & SettableFlag));
+      }
+
+      virtual void Set
+      (id element, wxAccessible &accessible, int childID, id value) const
+      {
+         wxAccStatus status = accessible.Select(childID, SelectFlag);
+         WXUNUSED(status);
+      }
+   };
+
+   // To do: for each of these attributes that is important, make a static
+   // object of a subclass of wxNSAccessibilityAttribute that gets and sets it.
+
+   /* Standard attributes
+    */
+
+   struct wxNSAccessibilityRoleAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityRoleAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityRoleAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         // Standard NSAccessibility roles that did not obviously correspond
+         // to any of the wxROLE constants
+         /*
+          NSAccessibilityTextAreaRole;
+          NSAccessibilityScrollAreaRole;
+          NSAccessibilityRadioGroupRole;
+          NSAccessibilityBusyIndicatorRole;
+          NSAccessibilityDrawerRole;
+          NSAccessibilitySystemWideRole;
+          NSAccessibilityBrowserRole;
+          NSAccessibilitySplitGroupRole;
+          NSAccessibilityColorWellRole;
+          NSAccessibilityMatteRole;
+          NSAccessibilityRulerRole;
+          NSAccessibilityRulerMarkerRole;
+          NSAccessibilityRelevanceIndicatorRole;
+          NSAccessibilityLevelIndicatorRole;
+
+          NSAccessibilityLayoutItemRole;
+
+          NSAccessibilityGridRole;
+          */
+
+         wxAccRole role;
+         if (wxACC_OK == accessible.GetRole(childID, &role)) switch (role)
+         {
+            case wxROLE_SYSTEM_ANIMATION:
+               return NSAccessibilityImageRole; // ??
+
+            case wxROLE_SYSTEM_APPLICATION:
+               return NSAccessibilityApplicationRole;
+
+            case wxROLE_SYSTEM_BORDER:
+               return NSAccessibilityGrowAreaRole; // ??
+
+            case wxROLE_SYSTEM_BUTTONDROPDOWN:
+            case wxROLE_SYSTEM_BUTTONDROPDOWNGRID:
+               return NSAccessibilityPopUpButtonRole;
+
+            case wxROLE_SYSTEM_BUTTONMENU:
+               return NSAccessibilityMenuButtonRole;
+
+            case wxROLE_SYSTEM_CELL:
+               return NSAccessibilityCellRole;
+
+            case wxROLE_SYSTEM_CHART:
+               return NSAccessibilityImageRole; // ??
+
+            case wxROLE_SYSTEM_CHECKBUTTON:
+               return NSAccessibilityCheckBoxRole;
+
+            case wxROLE_SYSTEM_COLUMN:
+            case wxROLE_SYSTEM_COLUMNHEADER:
+               return NSAccessibilityColumnRole;
+
+            case wxROLE_SYSTEM_COMBOBOX:
+               return NSAccessibilityComboBoxRole;
+
+            case wxROLE_SYSTEM_DIAGRAM:
+               return NSAccessibilityImageRole; // ??
+
+            case wxROLE_SYSTEM_DIAL:
+               return NSAccessibilitySliderRole; //??
+
+            case wxROLE_SYSTEM_DIALOG:
+               return NSAccessibilitySheetRole;
+
+            case wxROLE_SYSTEM_DOCUMENT:
+               return NSAccessibilityTextAreaRole; // ??
+
+            case wxROLE_SYSTEM_DROPLIST:
+               return NSAccessibilityMenuRole; // ??
+
+            case wxROLE_SYSTEM_GRAPHIC:
+               return NSAccessibilityImageRole;
+
+            case wxROLE_SYSTEM_GRIP:
+               return NSAccessibilityHandleRole;
+
+            case wxROLE_SYSTEM_GROUPING:
+               return NSAccessibilityGroupRole;
+
+            case wxROLE_SYSTEM_HELPBALLOON:
+               return NSAccessibilityHelpTagRole;
+
+            case wxROLE_SYSTEM_HOTKEYFIELD:
+               return NSAccessibilityTextFieldRole; // ??
+
+            case wxROLE_SYSTEM_INDICATOR:
+               return NSAccessibilityValueIndicatorRole;
+
+            case wxROLE_SYSTEM_LINK:
+               return NSAccessibilityLinkRole;
+
+            case wxROLE_SYSTEM_LIST:
+               return NSAccessibilityListRole;
+
+            case wxROLE_SYSTEM_LISTITEM:
+               return NSAccessibilityMenuItemRole; // ??
+
+            case wxROLE_SYSTEM_MENUBAR:
+               return NSAccessibilityMenuBarRole;
+
+            case wxROLE_SYSTEM_MENUITEM:
+               return NSAccessibilityMenuItemRole;
+
+            case wxROLE_SYSTEM_MENUPOPUP:
+               return NSAccessibilityMenuRole;
+
+            case wxROLE_SYSTEM_OUTLINE:
+               return NSAccessibilityOutlineRole;
+
+            case wxROLE_SYSTEM_OUTLINEITEM:
+               return NSAccessibilityDisclosureTriangleRole; // ??
+
+            case wxROLE_SYSTEM_PAGETAB:
+               return NSAccessibilityButtonRole; // ???
+
+            case wxROLE_SYSTEM_PAGETABLIST:
+               return NSAccessibilityTabGroupRole; // ??
+
+            case wxROLE_SYSTEM_PANE:
+               return NSAccessibilityLayoutAreaRole; // ??
+
+            case wxROLE_SYSTEM_PROGRESSBAR:
+               return NSAccessibilityProgressIndicatorRole;
+
+            case wxROLE_SYSTEM_PROPERTYPAGE:
+               return NSAccessibilitySheetRole; // ??
+
+            case wxROLE_SYSTEM_PUSHBUTTON:
+               return NSAccessibilityButtonRole;
+
+            case wxROLE_SYSTEM_RADIOBUTTON:
+               return NSAccessibilityRadioButtonRole;
+
+            case wxROLE_SYSTEM_ROWHEADER:
+            case wxROLE_SYSTEM_ROW:
+               return NSAccessibilityRowRole;
+
+            case wxROLE_SYSTEM_SCROLLBAR:
+               return NSAccessibilityScrollBarRole;
+
+            case wxROLE_SYSTEM_SEPARATOR:
+               return NSAccessibilitySplitterRole; // ??
+
+            case wxROLE_SYSTEM_SLIDER:
+               return NSAccessibilitySliderRole;
+
+            case wxROLE_SYSTEM_SPINBUTTON:
+               return NSAccessibilityIncrementorRole;
+
+            case wxROLE_SYSTEM_STATICTEXT:
+               return NSAccessibilityStaticTextRole;
+
+            case wxROLE_SYSTEM_STATUSBAR:
+               return NSAccessibilityStaticTextRole; // ??
+
+            case wxROLE_SYSTEM_TABLE:
+               return NSAccessibilityTableRole;
+
+            case wxROLE_SYSTEM_TEXT:
+               return NSAccessibilityTextFieldRole;
+
+            case wxROLE_SYSTEM_TITLEBAR:
+               return NSAccessibilityStaticTextRole; // ??
+
+            case wxROLE_SYSTEM_TOOLBAR:
+               return NSAccessibilityToolbarRole;
+
+            case wxROLE_SYSTEM_TOOLTIP:
+               return NSAccessibilityHelpTagRole; // ??
+
+            case wxROLE_SYSTEM_WHITESPACE:
+               return NSAccessibilityStaticTextRole; // ??
+
+            case wxROLE_SYSTEM_WINDOW:
+               return NSAccessibilityWindowRole;
+
+               // wxROLE constants that did not correspond to anything obvious
+               // in the list of standard NSAccessibility roles
+            case wxROLE_NONE:
+            case wxROLE_SYSTEM_ALERT:
+            case wxROLE_SYSTEM_CARET:
+            case wxROLE_SYSTEM_CHARACTER:
+            case wxROLE_SYSTEM_CLIENT:
+            case wxROLE_SYSTEM_CLOCK:
+            case wxROLE_SYSTEM_CURSOR:
+            case wxROLE_SYSTEM_EQUATION:
+            case wxROLE_SYSTEM_SOUND:
+            default:
+               return NSAccessibilityUnknownRole;
+         }
+         else
+            return NSAccessibilityUnknownRole;
+      }
+   } swxNSAccessibilityRoleAttribute;
+
+   struct wxNSAccessibilitySubroleAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilitySubroleAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilitySubroleAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         // Improve this
+         return NSAccessibilityUnknownSubrole;
+      }
+   } swxNSAccessibilitySubroleAttribute;
+
+   struct wxNSAccessibilityRoleDescriptionAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityRoleDescriptionAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityRoleDescriptionAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         id role =
+         swxNSAccessibilityRoleAttribute.Get(element, accessible, childID);
+         id subRole =
+         swxNSAccessibilitySubroleAttribute.Get(element, accessible, childID);
+         NSString *result =
+         NSAccessibilityRoleDescription((NSString*)role, (NSString*)subRole);
+         return result;
+      }
+   } swxNSAccessibilityRoleDescriptionAttribute;
+
+   wxNAccessibilityStringAttribute sxwNSAccessibilityHelpAttribute
+      (NSAccessibilityHelpAttribute, &wxAccessible::GetHelpText);
+
+   // Not different from value -- is that right?
+   wxNAccessibilityStringAttribute sxwNSAccessibilityValueAttribute
+      (NSAccessibilityValueAttribute, &wxAccessible::GetValue);
+
+#if 0
+   NSAccessibilityMinValueAttribute;		//(id)         - element's min value
+   NSAccessibilityMaxValueAttribute;		//(id)         - element's max value
 #endif
 
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_UNAVAILABLE, false,
+      0, true, wxACC_SEL_NONE // not settable
+   > swxNSAccessibilityEnabledAttribute(NSAccessibilityEnabledAttribute);
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_FOCUSED, true,
+      wxACC_STATE_SYSTEM_FOCUSABLE, true,
+      wxACC_SEL_TAKEFOCUS
+   > swxNSAccessibilityFocusedAttribute(NSAccessibilityFocusedAttribute);
+
+   struct wxNSAccessibilityParentAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityParentAttribute()
+      : wxNSAccessibilityAttribute(NSAccessibilityParentAttribute)
+      {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return nil != Get(element, accessible, childID);
+      }
+
+      virtual id Get
+      (id, wxAccessible &accessible, int childID) const
+      {
+         // I'm not using wxAccessible::GetParent() because the default
+         // implementation has the undesirable side effect of creating
+         // wxAccessible objects for windows that did not already have them.
+
+         wxWindow *window = accessible.GetWindow();
+
+         if (childID != wxACC_SELF)
+            // report parent of non-window accessible element
+            return window->GetPeer()->GetWXWidget();
+
+         // Report direct parent window if that defines a wxAccessible
+         wxWindow *parent = window->GetParent();
+         if (parent && parent->GetAccessible())
+         {
+            NSObject *widget = parent->GetPeer()->GetWXWidget();
+            return widget;
+         }
+
+         // Cause defaulting to the framework's definition of parent
+         return nil;
+      }
+   } swxNSAccessibilityParentAttribute;
+
+   //(NSArray *)  - elements you contain
+   struct wxNSAccessibilityChildrenAttributeBase : wxNSAccessibilityArrayAttribute
+   {
+      wxNSAccessibilityChildrenAttributeBase(NSString *name_)
+      : wxNSAccessibilityArrayAttribute(name_)
+      {}
+
+      virtual bool Condition
+         (wxAccessible &accessible, int childID,
+          wxAccessible *pChild) const = 0;
+
+      virtual bool IsPresent
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual unsigned GetCount
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         if (childID != 0)
+            return 0;
+
+         int childCount;
+         wxAccStatus status = accessible.GetChildCount(&childCount);
+         if (status != wxACC_OK || childCount <= 0)
+            return 0;
+         else
+            return childCount;
+      }
+
+      virtual id GetArrayElement
+      (id element, wxAccessible &accessible, int childID,
+       unsigned index) const
+      {
+         if (childID != 0)
+            return nil;
+
+         wxAccessible *child = NULL;
+         wxAccStatus status = accessible.GetChild(index + 1, &child);
+         if (status != wxACC_OK)
+            return nil;
+
+         if (!Condition(accessible, index + 1, child))
+            return nil;
+
+         return GetUIElement(accessible, index + 1, child);
+      }
+   };
+
+   struct wxNSAccessibilityChildrenAttribute
+   : wxNSAccessibilityChildrenAttributeBase
+   {
+      explicit
+      wxNSAccessibilityChildrenAttribute
+         (NSString *attr = NSAccessibilityChildrenAttribute)
+      : wxNSAccessibilityChildrenAttributeBase(attr)
+      {}
+
+      virtual bool Condition(wxAccessible &, int, wxAccessible *) const
+      {
+         return true;
+      }
+
+   } swxNSAccessibilityChildrenAttribute;
+
+   struct wxNSAccessibilityWindowAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityWindowAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityWindowAttribute) {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxWindow *pWindow = accessible.GetWindow(), *pParent;
+         while (!dynamic_cast<wxNonOwnedWindow*>(pWindow) &&
+            NULL != (pParent = pWindow->GetParent()))
+            pWindow = pParent;
+         NSObject *widget = pWindow->GetPeer()->GetWXWidget();
+         return widget;
+      }
+   } swxNSAccessibilityWindowAttribute;
+
+   struct wxNSAccessibilityTopLevelUIAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityTopLevelUIAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityTopLevelUIElementAttribute) {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return false;
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return element;
+         /*
+         id prevElement = element, newElement;
+         do try {
+            newElement =
+               [element accessibilityAttributeValue: NSAccessibilityParentAttribute];
+         }
+         catch(...) {
+            return prevElement;
+         }
+         while (newElement != NULL &&
+                (prevElement = element, element = newElement));
+         return element;
+          */
+      }
+   } swxNSAccessibilityTopLevelUIAttribute;
+
+   struct wxNSAccessibilitySelectedChildrenAttribute
+   : wxNSAccessibilityChildrenAttributeBase
+   {
+      explicit
+      wxNSAccessibilitySelectedChildrenAttribute
+         (NSString *attr = NSAccessibilitySelectedChildrenAttribute)
+      : wxNSAccessibilityChildrenAttributeBase(attr)
+      {}
+
+      virtual bool Condition
+      (wxAccessible &accessible, int childID,
+       wxAccessible *pChild) const
+      {
+         wxAccStatus status;
+         long state = 0;
+         if (pChild)
+            status = pChild->GetState(wxACC_SELF, &state);
+         else
+            status = accessible.GetState(childID, &state);
+
+         return (status == wxACC_OK &&
+                 0 != (state & wxACC_STATE_SYSTEM_SELECTED));
+      }
+   } swxNSAccessibilitySelectedChildrenAttribute;
+
+   struct wxNSAccessibilityVisibleChildrenAttribute
+   : wxNSAccessibilityChildrenAttributeBase
+   {
+      explicit
+      wxNSAccessibilityVisibleChildrenAttribute
+         (NSString *attr = NSAccessibilityVisibleChildrenAttribute)
+      : wxNSAccessibilityChildrenAttributeBase(attr)
+      {}
+
+      virtual bool Condition
+      (wxAccessible &accessible, int childID,
+       wxAccessible *pChild) const
+      {
+         wxAccStatus status;
+         long state = 0;
+         if (pChild)
+            status = pChild->GetState(wxACC_SELF, &state);
+         else
+            status = accessible.GetState(childID, &state);
+
+         return (status == wxACC_OK &&
+                 0 == (state & wxACC_STATE_SYSTEM_INVISIBLE));
+      }
+   } swxNSAccessibilityVisibleChildrenAttribute;
+
+   struct wxNSAccessibilityPositionAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityPositionAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityPositionAttribute) {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         return (wxACC_OK == accessible.GetLocation(rect, childID));
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         NSPoint point = { 0, 0 };
+         if (wxACC_OK == accessible.GetLocation(rect, childID))
+         {
+            int height;
+            ::wxDisplaySize(NULL, &height);
+            point.x = rect.x, point.y = height - rect.y - rect.height;
+         }
+         return [NSValue valueWithBytes: &point objCType: @encode(NSPoint)];
+      }
+   } swxNSAccessibilityPositionAttribute;
+
+   struct wxNSAccessibilitySizeAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilitySizeAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilitySizeAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         return (wxACC_OK == accessible.GetLocation(rect, childID));
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         NSSize size = { 0, 0 };
+         if (wxACC_OK == accessible.GetLocation(rect, childID))
+            size.width = rect.width, size.height = rect.height;
+         return [NSValue valueWithBytes: &size objCType: @encode(NSSize)];
+      }
+   } swxNSAccessibilitySizeAttribute;
+
+   // Make "contents" no different from "children" -- is that right?
+   wxNSAccessibilityChildrenAttribute
+      swxNSAccessibilityContentsAttribute(NSAccessibilityContentsAttribute);
+
+   wxNAccessibilityStringAttribute sxwNSAccessibilityTitleAttribute
+      (NSAccessibilityTitleAttribute, &wxAccessible::GetName);
+   wxNAccessibilityStringAttribute sxwNSAccessibilityDescriptionAttribute
+      (NSAccessibilityDescriptionAttribute, &wxAccessible::GetDescription);
+
+#if 0
+   NSAccessibilityShownMenuAttribute		//(id)         - menu being displayed
+   ;
+#endif
+
+   wxNAccessibilityStringAttribute sxwNSAccessibilityValueDescriptionAttribute
+      (NSAccessibilityValueDescriptionAttribute, &wxAccessible::GetValue);
+
+#if 0
+   /* Misc attributes
+    */
+   NSAccessibilityPreviousContentsAttribute;	//(NSArray *)  - main elements
+   NSAccessibilityNextContentsAttribute;	//(NSArray *)  - main elements
+   NSAccessibilityHeaderAttribute;		//(id)         - UIElement for header.
+   NSAccessibilityEditedAttribute;		//(NSNumber *) - (boolValue) is it dirty?
+   NSAccessibilityTabsAttribute;		//(NSArray *)  - UIElements for tabs
+   NSAccessibilityHorizontalScrollBarAttribute;//(id)       - UIElement for the horizontal scroller
+   NSAccessibilityVerticalScrollBarAttribute;//(id)         - UIElement for the vertical scroller
+   NSAccessibilityOverflowButtonAttribute;	//(id)         - UIElement for overflow
+   NSAccessibilityIncrementButtonAttribute;	//(id)         - UIElement for increment
+   NSAccessibilityDecrementButtonAttribute;	//(id)         - UIElement for decrement
+   NSAccessibilityFilenameAttribute;		//(NSString *) - filename
+#endif
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_EXPANDED, true,
+      0, true, wxACC_SEL_NONE // not settable
+   > swxNSAccessibilityExpandedAttribute(NSAccessibilityExpandedAttribute);
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_SELECTED, true,
+      wxACC_STATE_SYSTEM_SELECTABLE, true,
+      wxACC_SEL_TAKESELECTION
+   > swxNSAccessibilitySelectedAttribute(NSAccessibilitySelectedAttribute);
+
+#if 0
+   NSAccessibilitySplittersAttribute;	//(NSArray *)  - UIElements for splitters
+   NSAccessibilityDocumentAttribute;		//(NSString *) - url as string - for open document
+   NSAccessibilityURLAttribute		//(NSURL *)    - url
+   ;
+   NSAccessibilityIndexAttribute		//(NSNumber *)  - (intValue)
+   ;
+
+   NSAccessibilityRowCountAttribute		//(NSNumber *)  - (intValue) number of rows
+   ;
+   NSAccessibilityColumnCountAttribute	//(NSNumber *)  - (intValue) number of columns
+   ;
+   NSAccessibilityOrderedByRowAttribute	//(NSNumber *)  - (boolValue) is ordered by row?
+   ;
+
+   NSAccessibilityWarningValueAttribute	//(id)  - warning value of a level indicator, typically a number
+   ;
+   NSAccessibilityCriticalValueAttribute	//(id)  - critical value of a level indicator, typically a number
+   ;
+   NSAccessibilityPlaceholderValueAttribute	//(NSString *)  - placeholder value of a control such as a text field
+   ;
+
+   /* Linkage attributes
+    */
+   NSAccessibilityTitleUIElementAttribute;		//(id)	      - UIElement for the title
+   NSAccessibilityServesAsTitleForUIElementsAttribute//(NSArray *) - UIElements this titles
+   ;
+   NSAccessibilityLinkedUIElementsAttribute		//(NSArray *) - corresponding UIElements
+   ;
+
+
+   /* Text-specific attributes
+    */
+   NSAccessibilitySelectedTextAttribute;		//(NSString *) - selected text
+   NSAccessibilitySelectedTextRangeAttribute;	//(NSValue *)  - (rangeValue) range of selected text
+   NSAccessibilityNumberOfCharactersAttribute	//(NSNumber *) - number of characters
+   ;
+   NSAccessibilityVisibleCharacterRangeAttribute	//(NSValue *)  - (rangeValue) range of visible text
+   ;
+   NSAccessibilitySharedTextUIElementsAttribute	//(NSArray *)  - text views sharing text
+   ;
+   NSAccessibilitySharedCharacterRangeAttribute	//(NSValue *)  - (rangeValue) part of shared text in this view
+   ;
+   NSAccessibilityInsertionPointLineNumberAttribute	//(NSNumber *) - line# containing caret
+   ;
+   NSAccessibilitySelectedTextRangesAttribute	//(NSArray *) - array of NSValue (rangeValue) ranges of selected text
+   ;
+
+
+   /* Parameterized text-specific attributes
+    */
+   NSAccessibilityLineForIndexParameterizedAttribute		//(NSNumber *) - line# for char index; param:(NSNumber *)
+   ;
+   NSAccessibilityRangeForLineParameterizedAttribute		//(NSValue *)  - (rangeValue) range of line; param:(NSNumber *)
+   ;
+   NSAccessibilityStringForRangeParameterizedAttribute	//(NSString *) - substring; param:(NSValue * - rangeValue)
+   ;
+   NSAccessibilityRangeForPositionParameterizedAttribute	//(NSValue *)  - (rangeValue) composed char range; param:(NSValue * - pointValue)
+   ;
+   NSAccessibilityRangeForIndexParameterizedAttribute	//(NSValue *)  - (rangeValue) composed char range; param:(NSNumber *)
+   ;
+   NSAccessibilityBoundsForRangeParameterizedAttribute	//(NSValue *)  - (rectValue) bounds of text; param:(NSValue * - rangeValue)
+   ;
+   NSAccessibilityRTFForRangeParameterizedAttribute		//(NSData *)   - rtf for text; param:(NSValue * - rangeValue)
+   ;
+   NSAccessibilityStyleRangeForIndexParameterizedAttribute	//(NSValue *)  - (rangeValue) extent of style run; param:(NSNumber *)
+   ;
+   NSAccessibilityAttributedStringForRangeParameterizedAttribute //(NSAttributedString *) - does _not_ use attributes from Appkit/AttributedString.h
+   ;
+
+
+   /* Text attributed string attributes and constants
+    */
+   NSAccessibilityFontTextAttribute			//(NSDictionary *)  - NSAccessibilityFontXXXKey's
+   ;
+   NSAccessibilityForegroundColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityBackgroundColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityUnderlineColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityStrikethroughColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityUnderlineTextAttribute		//(NSNumber *)	    - underline style
+   ;
+   NSAccessibilitySuperscriptTextAttribute		//(NSNumber *)	    - superscript>0, subscript<0
+   ;
+   NSAccessibilityStrikethroughTextAttribute		//(NSNumber *)	    - (boolValue)
+   ;
+   NSAccessibilityShadowTextAttribute		//(NSNumber *)	    - (boolValue)
+   ;
+   NSAccessibilityAttachmentTextAttribute		//id - corresponding element
+   ;
+   NSAccessibilityLinkTextAttribute			//id - corresponding element
+   ;
+   NSAccessibilityMisspelledTextAttribute		//(NSNumber *)	    - (boolValue)
+   ;
+
+   NSAccessibilityFontNameKey	// required
+   ;
+   NSAccessibilityFontFamilyKey	// optional
+   ;
+   NSAccessibilityVisibleNameKey	// optional
+   ;
+   NSAccessibilityFontSizeKey	// required
+   ;
+
+
+   /* Window-specific attributes
+    */
+   NSAccessibilityMainAttribute;		//(NSNumber *) - (boolValue) is it the main window?
+   NSAccessibilityMinimizedAttribute;	//(NSNumber *) - (boolValue) is window minimized?
+   NSAccessibilityCloseButtonAttribute;	//(id) - UIElement for close box (or nil)
+   NSAccessibilityZoomButtonAttribute;	//(id) - UIElement for zoom box (or nil)
+   NSAccessibilityMinimizeButtonAttribute;	//(id) - UIElement for miniaturize box (or nil)
+   NSAccessibilityToolbarButtonAttribute;	//(id) - UIElement for toolbar box (or nil)
+   NSAccessibilityProxyAttribute;		//(id) - UIElement for title's icon (or nil)
+   NSAccessibilityGrowAreaAttribute;		//(id) - UIElement for grow box (or nil)
+   NSAccessibilityModalAttribute		//(NSNumber *) - (boolValue) is the window modal
+   ;
+   NSAccessibilityDefaultButtonAttribute	//(id) - UIElement for default button
+   ;
+   NSAccessibilityCancelButtonAttribute	//(id) - UIElement for cancel button
+   ;
+
+   /* Application-specific attributes
+    */
+   NSAccessibilityMenuBarAttribute;		//(id)         - UIElement for the menu bar
+   NSAccessibilityWindowsAttribute;		//(NSArray *)  - UIElements for the windows
+   NSAccessibilityFrontmostAttribute;	//(NSNumber *) - (boolValue) is the app active?
+   NSAccessibilityHiddenAttribute;		//(NSNumber *) - (boolValue) is the app hidden?
+   NSAccessibilityMainWindowAttribute;	//(id)         - UIElement for the main window.
+   NSAccessibilityFocusedWindowAttribute;	//(id)         - UIElement for the key window.
+   NSAccessibilityFocusedUIElementAttribute;	//(id)         - Currently focused UIElement.
+
+   NSAccessibilityOrientationAttribute;	//(NSString *) - NSAccessibilityXXXOrientationValue
+   NSAccessibilityVerticalOrientationValue;
+   NSAccessibilityHorizontalOrientationValue;
+   NSAccessibilityUnknownOrientationValue	;
+
+   NSAccessibilityColumnTitlesAttribute;	//(NSArray *)  - UIElements for titles
+
+   NSAccessibilitySearchButtonAttribute	//(id)         - UIElement for search field search btn
+   ;
+   NSAccessibilitySearchMenuAttribute	//(id)         - UIElement for search field menu
+   ;
+   NSAccessibilityClearButtonAttribute	//(id)         - UIElement for search field clear btn
+   ;
+
+
+   /* Table/outline view attributes
+    */
+   NSAccessibilityRowsAttribute;		//(NSArray *)  - UIElements for rows
+   NSAccessibilityVisibleRowsAttribute;	//(NSArray *)  - UIElements for visible rows
+   NSAccessibilitySelectedRowsAttribute;	//(NSArray *)  - UIElements for selected rows
+   NSAccessibilityColumnsAttribute;		//(NSArray *)  - UIElements for columns
+   NSAccessibilityVisibleColumnsAttribute;	//(NSArray *)  - UIElements for visible columns
+   NSAccessibilitySelectedColumnsAttribute;	//(NSArray *)  - UIElements for selected columns
+   NSAccessibilitySortDirectionAttribute	//(NSString *) - see sort direction values below
+   ;
+
+   /* Cell-based table attributes
+    */
+   NSAccessibilitySelectedCellsAttribute ;	//(NSArray *)  - UIElements for selected cells
+   NSAccessibilityVisibleCellsAttribute ;	//(NSArray *)  - UIElements for visible cells
+   NSAccessibilityRowHeaderUIElementsAttribute ;	//(NSArray *)  - UIElements for row headers
+   NSAccessibilityColumnHeaderUIElementsAttribute ;	//(NSArray *)  - UIElements for column headers
+
+   /* Cell-based table parameterized attributes.  The parameter for this attribute is an NSArray containing two NSNumbers, the first NSNumber specifies the column index, the second NSNumber specifies the row index.
+    */
+   NSAccessibilityCellForColumnAndRowParameterizedAttribute ;  // (id) - UIElement for cell at specified row and column
+
+   /* Cell attributes.  The index range contains both the starting index, and the index span in a table.
+    */
+   NSAccessibilityRowIndexRangeAttribute ;	//(NSValue *)  - (rangeValue) location and row span
+   NSAccessibilityColumnIndexRangeAttribute ;   //(NSValue *)  - (rangeValue) location and column span
+
+   /* Layout area attributes
+    */
+   NSAccessibilityHorizontalUnitsAttribute ;   //(NSString *) - see ruler unit values below
+   NSAccessibilityVerticalUnitsAttribute ;	    //(NSString *) - see ruler unit values below
+   NSAccessibilityHorizontalUnitDescriptionAttribute ; //(NSString *)
+   NSAccessibilityVerticalUnitDescriptionAttribute ;    //(NSString *)
+
+   /* Layout area parameterized attributes
+    */
+   NSAccessibilityLayoutPointForScreenPointParameterizedAttribute ; //(NSValue *)  - (pointValue); param:(NSValue * - pointValue)
+   NSAccessibilityLayoutSizeForScreenSizeParameterizedAttribute ; //(NSValue *)  - (sizeValue); param:(NSValue * - sizeValue)
+   NSAccessibilityScreenPointForLayoutPointParameterizedAttribute ; //(NSValue *)  - (pointValue); param:(NSValue * - pointValue)
+   NSAccessibilityScreenSizeForLayoutSizeParameterizedAttribute ; //(NSValue *)  - (sizeValue); param:(NSValue * - sizeValue)
+
+   /* Layout item attributes
+    */
+   NSAccessibilityHandlesAttribute ; //(NSArray *)  - UIElements for handles
+
+   /* Sort direction values
+    */
+   NSAccessibilityAscendingSortDirectionValue	;
+   NSAccessibilityDescendingSortDirectionValue	;
+   NSAccessibilityUnknownSortDirectionValue		;
+
+   /* Outline attributes
+    */
+   NSAccessibilityDisclosingAttribute;	//(NSNumber *) - (boolValue) is diclosing rows?
+   NSAccessibilityDisclosedRowsAttribute;	//(NSArray *)  - UIElements for disclosed rows
+   NSAccessibilityDisclosedByRowAttribute;	//(id)         - UIElement for disclosing row
+   NSAccessibilityDisclosureLevelAttribute	//(NSNumber *) - indentation level
+   ;
+
+   /* Slider attributes
+    */
+   NSAccessibilityAllowedValuesAttribute	//(NSArray *) - array of allowed values
+   ;
+   NSAccessibilityLabelUIElementsAttribute	//(NSArray *) - array of label UIElements
+   ;
+   NSAccessibilityLabelValueAttribute	//(NSNumber *) - value of a label UIElement
+   ;
+
+   /* Matte attributes
+    */
+   NSAccessibilityMatteHoleAttribute		//(NSValue *) - (rect value) bounds of matte hole in screen coords
+   ;
+   NSAccessibilityMatteContentUIElementAttribute //(id) - UIElement clipped by the matte
+   ;
+
+   /* Ruler view attributes
+    */
+   NSAccessibilityMarkerUIElementsAttribute		//(NSArray *)
+   ;
+   NSAccessibilityMarkerValuesAttribute		//
+   ;
+   NSAccessibilityMarkerGroupUIElementAttribute	//(id)
+   ;
+   NSAccessibilityUnitsAttribute			//(NSString *) - see ruler unit values below
+   ;
+   NSAccessibilityUnitDescriptionAttribute		//(NSString *)
+   ;
+   NSAccessibilityMarkerTypeAttribute		//(NSString *) - see ruler marker type values below
+   ;
+   NSAccessibilityMarkerTypeDescriptionAttribute	//(NSString *)
+   ;
+
+   /* Deprecated
+    */
+   NSAccessibilityHorizontialUnitsAttribute ;
+   NSAccessibilityHorizontialUnitDescriptionAttribute ;
+#endif
+
+}
+
+NSArray *wxOSX_accessibilityAttributeNames( id self, SEL _cmd )
+{
+   // Pass-through first
+   typedef NSArray *(*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd);
+
+   // Add more attributes
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+      return findAttributeNames( self, *accessible, wxACC_SELF, result );
+
+   return result;
+}
+
+id wxOSX_accessibilityAttributeValue( id self, SEL _cmd, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+         findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+         return pAttribute->Get(self, *accessible, wxACC_SELF);
+   }
+
+   // Otherwise, pass-through
+   typedef id (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+BOOL wxOSX_accessibilityIsAttributeSettable( id self, SEL _cmd, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+         findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+         return pAttribute->IsSettable(self, *accessible, wxACC_SELF);
+   }
+
+   // Otherwise, pass-through
+   typedef BOOL (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   BOOL result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+void wxOSX_accessibilitySetValue_forAttribute( id self, SEL _cmd, id value, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+         findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+      {
+         if (pAttribute->IsSettable(self, *accessible, wxACC_SELF))
+            pAttribute->Set(self, *accessible, wxACC_SELF, value);
+         return;
+      }
+   }
+
+   // Otherwise, pass-through
+   typedef void (*Function)(id, SEL, id, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   superimpl(self, _cmd, value, attribute);
+}
+
+NSArray *wxOSX_accessibilityParameterizedAttributeNames( id self, SEL _cmd )
+{
+   typedef NSArray *(*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd);
+   return result;
+}
+
+id wxOSX_accessibilityAttributeValue_forParameter
+   ( id self, SEL _cmd, NSString *attribute, id parameter )
+{
+   typedef id (*Function)(id, SEL, NSString*, id);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd, attribute, parameter);
+   return result;
+}
+
+NSArray *wxOSX_accessibilityActionNames( id self, SEL _cmd )
+{
+#if 0
+   /* Actions
+    */
+NSAccessibilityPressAction;
+NSAccessibilityIncrementAction;
+NSAccessibilityDecrementAction;
+NSAccessibilityConfirmAction;
+NSAccessibilityPickAction;
+NSAccessibilityCancelAction;
+NSAccessibilityRaiseAction;
+NSAccessibilityShowMenuAction;
+NSAccessibilityDeleteAction;
+#endif
+
+   // This function produces an array of standard action string keys, which are
+   // not localized action descriptions.  So wxAccessible::GetDefaultAction()
+   // is not what we want.
+
+   // So in default of a better thing to do,
+   // we just give everything one press action, and only in case a default
+   // action is defined.
+   wxAccessible *pAccessible = findAccessible(self);
+   if (pAccessible)
+   {
+      wxString unused;
+      wxAccStatus status = pAccessible->GetDefaultAction(wxACC_SELF, &unused);
+      if (status == wxACC_OK)
+      {
+         return [NSArray arrayWithObject: NSAccessibilityPressAction];
+      }
+   }
+
+   typedef NSArray *(*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd);
+   return result;
+}
+
+NSString *wxOSX_accessibilityActionDescription( id self, SEL _cmd, NSString *action )
+{
+   NSString *result = NSAccessibilityActionDescription(action);
+   if (result)
+      return result;
+
+   typedef NSString *(*Function)(id, SEL, NSString*);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   result = superimpl(self, _cmd, action);
+   return result;
+}
+
+void wxOSX_accessibilityPerformAction( id self, SEL _cmd, NSString *action )
+{
+   wxAccessible *pAccessible = findAccessible(self);
+   if (pAccessible)
+   {
+      wxAccStatus status = pAccessible->DoDefaultAction(wxACC_SELF);
+      if (status == wxACC_OK)
+         return;
+   }
+
+   typedef void (*Function)(id, SEL, NSString*);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   superimpl(self, _cmd, action);
+}
+
+BOOL wxOSX_accessibilityIsIgnored( id self, SEL _cmd )
+{
+   wxAccessible *pAccessible = findAccessible(self);
+   if (pAccessible)
+      return NO;
+
+   typedef BOOL (*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   BOOL result = superimpl(self, _cmd);
+   return result;
+}
+
+id wxOSX_accessibilityHitTest( id self, SEL _cmd, NSPoint point )
+{
+   typedef id (*Function)(id, SEL, NSPoint);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd, point);
+   return result;
+}
+
+id wxOSX_accessibilityFocusedUIElement( id self, SEL _cmd )
+{
+   typedef id (*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd);
+   return result;
+}
+
+NSUInteger wxOSX_accessibilityIndexOfChild( id self, SEL _cmd, id child )
+{
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      return swxNSAccessibilityChildrenAttribute
+         .IndexOfValue(self, *accessible, wxACC_SELF, child);
+   }
+
+   typedef NSUInteger (*Function)(id, SEL, id);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSUInteger result = superimpl(self, _cmd, child);
+   return result;
+}
+
+NSUInteger wxOSX_accessibilityArrayAttributeCount( id self, SEL _cmd, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+      {
+         const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+            dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+         if (pArrayAttribute)
+         {
+            return pArrayAttribute->GetCount(self, *accessible, wxACC_SELF);
+         }
+      }
+   }
+
+   // Otherwise, pass-through
+   typedef NSUInteger (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSUInteger result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+NSArray *wxOSX_accessibilityArrayAttributeValues_index_maxCount
+   ( id self, SEL _cmd, NSString *attribute, NSUInteger index, NSUInteger maxCount )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+      {
+         const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+         dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+         if (pArrayAttribute)
+         {
+            return pArrayAttribute->GetValues
+               (self, *accessible, wxACC_SELF, index, maxCount);
+         }
+      }
+   }
+
+   // Otherwise, pass-through
+   typedef NSArray *(*Function)(id, SEL, NSString *, NSUInteger, NSUInteger);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd, attribute, index, maxCount);
+   return result;
+}
+
+BOOL wxOSX_accessibilitySetOverrideValue_forAttribute( id self, SEL _cmd, NSString *attribute )
+{
+   typedef BOOL (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   BOOL result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+
+#endif
+
+NSString* wxOSX_stringValue(id self, SEL _cmd)
+{
+   if ([[self superclass] instancesRespondToSelector: _cmd])
+   {
+      typedef NSString* (*Function)(id, SEL);
+      Function superimpl = (Function)
+         [[self superclass] instanceMethodForSelector:_cmd];
+      return superimpl(self, _cmd);
+   }
+   else
+      return @"";
+}
+
 void wxOSX_mouseEvent(NSView* self, SEL _cmd, NSEvent *event)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1063,7 +2484,7 @@ void wxOSX_cursorUpdate(NSView* self, SEL _cmd, NSEvent *event)
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
     if (impl == NULL)
         return;
-    
+
     impl->cursorUpdate(event, self, _cmd);
 }
 
@@ -1236,7 +2657,7 @@ void wxOSX_drawRect(NSView* self, SEL _cmd, NSRect rect)
             wxWindow* win = impl->GetWXPeer();
             if ( win->UseBgCol() )
             {
-                
+
                 CGContextRef context = (CGContextRef) [[NSGraphicsContext currentContext] graphicsPort];
                 CGContextSaveGState( context );
 
@@ -1247,7 +2668,7 @@ void wxOSX_drawRect(NSView* self, SEL _cmd, NSRect rect)
                 CGContextRestoreGState( context );
             }
         }
-        else 
+        else
         {
             // just call the superclass handler, we don't need any custom wx drawing
             // here and it seems to work fine:
@@ -1458,7 +2879,7 @@ void wxWidgetCocoaImpl::mouseEvent(WX_NSEvent event, WXWidget slf, void *_cmd)
         if ( hitview == NULL || hitview != slf)
             return;
     }
-    
+
     if ( !DoHandleMouseEvent(event) )
     {
         // for plain NSView mouse events would propagate to parents otherwise
@@ -1467,19 +2888,19 @@ void wxWidgetCocoaImpl::mouseEvent(WX_NSEvent event, WXWidget slf, void *_cmd)
         {
             wxOSX_EventHandlerPtr superimpl = (wxOSX_EventHandlerPtr) [[slf superclass] instanceMethodForSelector:(SEL)_cmd];
             superimpl(slf, (SEL)_cmd, event);
-            
+
             // super of built-ins keeps the mouse up, as wx expects this event, we have to synthesize it
             // only trigger if at this moment the mouse is already up, and the control is still existing after the event has
             // been handled (we do this by looking up the native NSView's peer from the hash map, that way we are sure the info
             // is current - even when the instance memory of ourselves may have been freed ...
-            
+
             wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( slf );
             if ( [ event type]  == NSLeftMouseDown && !wxGetMouseState().LeftIsDown() && impl != NULL )
             {
                 wxMouseEvent wxevent(wxEVT_LEFT_DOWN);
                 SetupMouseEvent(wxevent , event) ;
                 wxevent.SetEventType(wxEVT_LEFT_UP);
-                
+
                 GetWXPeer()->HandleWindowEvent(wxevent);
             }
         }
@@ -1498,7 +2919,7 @@ void wxWidgetCocoaImpl::cursorUpdate(WX_NSEvent event, WXWidget slf, void *_cmd)
 bool wxWidgetCocoaImpl::SetupCursor(WX_NSEvent event)
 {
     extern wxCursor gGlobalCursor;
-    
+
     if ( gGlobalCursor.IsOk() )
     {
         gGlobalCursor.MacInstall();
@@ -1510,7 +2931,7 @@ bool wxWidgetCocoaImpl::SetupCursor(WX_NSEvent event)
         wxCoord x,y;
         SetupCoordinates(x, y, event);
         wxPoint cursorPoint( x , y ) ;
-        
+
         while ( cursorTarget && !cursorTarget->MacSetupCursor( cursorPoint ) )
         {
             // at least in GTK cursor events are not propagated either ...
@@ -1522,7 +2943,7 @@ bool wxWidgetCocoaImpl::SetupCursor(WX_NSEvent event)
                 cursorPoint += cursorTarget->GetPosition();
 #endif
         }
-        
+
         return cursorTarget != NULL;
     }
 }
@@ -1534,14 +2955,14 @@ void wxWidgetCocoaImpl::keyEvent(WX_NSEvent event, WXWidget slf, void *_cmd)
 
     if ( [event type] == NSKeyDown )
     {
-        // there are key equivalents that are not command-combos and therefore not handled by cocoa automatically, 
+        // there are key equivalents that are not command-combos and therefore not handled by cocoa automatically,
         // therefore we call the menubar directly here, exit if the menu is handling the shortcut
         if ( [[[NSApplication sharedApplication] mainMenu] performKeyEquivalent:event] )
             return;
-    
+
         m_lastKeyDownEvent = event;
     }
-    
+
     if ( GetFocusedViewInWindow([slf window]) != slf || m_hasEditor || !DoHandleKeyEvent(event) )
     {
         wxOSX_EventHandlerPtr superimpl = (wxOSX_EventHandlerPtr) [[slf superclass] instanceMethodForSelector:(SEL)_cmd];
@@ -2172,10 +3593,10 @@ void wxWidgetCocoaImpl::doCommandBySelector(void* sel, WXWidget slf, void* _cmd)
 bool wxWidgetCocoaImpl::performKeyEquivalent(WX_NSEvent event, WXWidget slf, void *_cmd)
 {
     bool handled = false;
-    
+
     wxKeyEvent wxevent(wxEVT_KEY_DOWN);
     SetupKeyEvent( wxevent, event );
-   
+
     // because performKeyEquivalent is going up the entire view hierarchy, we don't have to
     // walk up the ancestors ourselves but let cocoa do it
 #if wxUSE_ACCEL
@@ -2183,11 +3604,11 @@ bool wxWidgetCocoaImpl::performKeyEquivalent(WX_NSEvent event, WXWidget slf, voi
     if (command != -1)
     {
         wxEvtHandler * const handler = m_wxPeer->GetEventHandler();
-        
+
         wxCommandEvent command_event( wxEVT_MENU, command );
         command_event.SetEventObject( wxevent.GetEventObject() );
         handled = handler->ProcessEvent( command_event );
-        
+
         if ( !handled )
         {
             // accelerators can also be used with buttons, try them too
@@ -2230,7 +3651,7 @@ bool wxWidgetCocoaImpl::resignFirstResponder(WXWidget slf, void *_cmd)
 {
     wxOSX_FocusHandlerPtr superimpl = (wxOSX_FocusHandlerPtr) [[slf superclass] instanceMethodForSelector:(SEL)_cmd];
     BOOL r = superimpl(slf, (SEL)_cmd);
-    
+
     // wxNSTextFields and wxNSComboBoxes have an editor as real responder, therefore they get
     // a resign notification when their editor takes over, don't trigger  event here, the control
     // gets a controlTextDidEndEditing notification which will send a focus kill.
@@ -2254,7 +3675,7 @@ bool wxWidgetCocoaImpl::isFlipped(WXWidget slf, void *WXUNUSED(_cmd))
 void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
 {
     // preparing the update region
-    
+
     wxRegion updateRgn;
 
     // since adding many rects to a region is a costly process, by default use the bounding rect
@@ -2269,7 +3690,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
 #else
     updateRgn.Union(wxFromNSRect(slf,*(NSRect*)rect));
 #endif
-    
+
     wxWindow* wxpeer = GetWXPeer();
 
     if ( wxpeer->MacGetLeftBorderSize() != 0 || wxpeer->MacGetTopBorderSize() != 0 )
@@ -2277,7 +3698,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
         // as this update region is in native window locals we must adapt it to wx window local
         updateRgn.Offset( wxpeer->MacGetLeftBorderSize() , wxpeer->MacGetTopBorderSize() );
     }
-    
+
     // Restrict the update region to the shape of the window, if any, and also
     // remember the region that we need to clear later.
     wxNonOwnedWindow* const tlwParent = wxpeer->MacGetTopLevelWindow();
@@ -2304,7 +3725,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             }
         }
     }
-    
+
     wxpeer->GetUpdateRegion() = updateRgn;
 
     // setting up the drawing context
@@ -2314,7 +3735,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
     if ( context != NULL )
     {
         CGContextSaveGState( context );
-        
+
 #if OSX_DEBUG_DRAWING
         CGContextBeginPath( context );
         CGContextMoveToPoint(context, 0, 0);
@@ -2329,7 +3750,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
         CGContextClosePath( context );
         CGContextStrokePath(context);
 #endif
-        
+
         if ( ![slf isFlipped] )
         {
             CGContextTranslateCTM( context, 0,  [m_osxView bounds].size.height );
@@ -2343,20 +3764,44 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
         CGContextRestoreGState( context );
         CGContextSaveGState( context );
     }
-    
+
     if ( !handled )
     {
         // call super
         SEL _cmd = @selector(drawRect:);
         wxOSX_DrawRectHandlerPtr superimpl = (wxOSX_DrawRectHandlerPtr) [[slf superclass] instanceMethodForSelector:_cmd];
-        superimpl(slf, _cmd, *(NSRect*)rect);
-        if ( context != NULL )
+
+        wxWindow *peer = GetWXPeer();
+        bool hasFocus = peer->HasFocus();
+        if (hasFocus && peer->NeedsFocusRing())
         {
-            CGContextRestoreGState( context );
-            CGContextSaveGState( context );
+           superimpl(slf, _cmd, *(NSRect*)rect);
+
+           // Paint it again, without text, causing focus halo to be
+           // superimposed about all else
+           if ( context != NULL )
+           {
+              HIThemeBeginFocus( context, kHIThemeFocusRingOnly, NULL );
+              CGContextSetTextDrawingMode( context, kCGTextInvisible );
+              superimpl(slf, _cmd, *(NSRect*)rect);
+              HIThemeEndFocus( context );
+
+              CGContextRestoreGState( context );
+              CGContextSaveGState( context );
+            }
+        }
+        else
+        {
+           superimpl(slf, _cmd, *(NSRect*)rect);
+
+           if ( context != NULL )
+           {
+               CGContextRestoreGState( context );
+               CGContextSaveGState( context );
+           }
         }
     }
-    
+
     if ( context != NULL )
     {
         // as we called restore above, we have to flip again if necessary
@@ -2365,7 +3810,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             CGContextTranslateCTM( context, 0,  [m_osxView bounds].size.height );
             CGContextScaleCTM( context, 1, -1 );
         }
-        
+
         if ( isTopLevel )
         {
             // We also need to explicitly draw the part of the top level window
@@ -2379,7 +3824,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
                 dc.SetDeviceClippingRegion(clearRgn);
                 dc.Clear();
             }
-            
+
 #if wxUSE_GRAPHICS_CONTEXT
             // If the window shape is defined by a path, stroke the path to show
             // the window border.
@@ -2393,7 +3838,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             }
 #endif // wxUSE_GRAPHICS_CONTEXT
         }
-        
+
         wxpeer->MacPaintChildrenBorders();
         CGContextRestoreGState( context );
     }
@@ -2417,7 +3862,7 @@ void wxWidgetCocoaImpl::controlDoubleAction( WXWidget WXUNUSED(slf), void *WXUNU
 void wxWidgetCocoaImpl::controlTextDidChange()
 {
     wxWindow* wxpeer = (wxWindow*)GetWXPeer();
-    if ( wxpeer ) 
+    if ( wxpeer )
     {
         // since native rtti doesn't have to be enabled and wx' rtti is not aware of the mixin wxTextEntry, workaround is needed
         wxTextCtrl *tc = wxDynamicCast( wxpeer , wxTextCtrl );
@@ -2426,7 +3871,7 @@ void wxWidgetCocoaImpl::controlTextDidChange()
             tc->SendTextUpdatedEventIfAllowed();
         else if ( cb )
             cb->SendTextUpdatedEventIfAllowed();
-        else 
+        else
         {
             wxFAIL_MSG("Unexpected class for controlTextDidChange event");
         }
@@ -2447,6 +3892,435 @@ void wxWidgetCocoaImpl::controlTextDidChange()
 
 #endif
 
+@implementation wxAccessibilityChild
+- (id)initWithAccessible: (wxAccessible*) accessible_
+                  andNumber: (NSInteger) number_
+{
+   self = [super init];
+   accessible = accessible_;
+   number = number_;
+   return self;
+}
+
++ (id)accessibilityChildWithAccessible: (wxAccessible*)accessible_
+                             andNumber: (NSInteger)number_;
+{
+   return [
+      [[wxAccessibilityChild alloc]
+          initWithAccessible: accessible_ andNumber: number_]
+      autorelease
+   ];
+}
+
+- (NSString*)stringValue
+{
+   // For debugging
+   return @"";
+}
+
+- (BOOL)isEqual:(id)object
+{
+   if ([object isMemberOfClass: [wxAccessibilityChild class]])
+   {
+      wxAccessibilityChild *other = (wxAccessibilityChild*)object;
+      if (accessible == other->accessible && number == other->number)
+         return YES;
+   }
+   return NO;
+}
+
+// Implement the NSObject (NSAccessibility) informal protocol with appropriate
+// forwards to the wxAccessible object
+
+/* Attribute methods
+ */
+- (NSArray *)accessibilityAttributeNames
+{
+   return findAttributeNames( self, *accessible, number, NULL );
+}
+
+- (id)accessibilityAttributeValue:(NSString *)attribute
+{
+   const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+      return pAttribute->Get(self, *accessible, number);
+   return [super accessibilityAttributeValue: attribute];
+}
+
+- (BOOL)accessibilityIsAttributeSettable:(NSString *)attribute
+{
+   const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+      return pAttribute->IsSettable(self, *accessible, number);
+   return [super accessibilityIsAttributeSettable: attribute];
+}
+
+- (void)accessibilitySetValue:(id)value forAttribute:(NSString *)attribute
+{
+   const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+   {
+      if (pAttribute->IsSettable(self, *accessible, number))
+         pAttribute->Set(self, *accessible, number, value);
+      return;
+   }
+
+   [super accessibilitySetValue: value forAttribute: attribute];
+}
+
+/* Parameterized Attribute methods
+ */
+- (NSArray *)accessibilityParameterizedAttributeNames
+{
+   return [super accessibilityParameterizedAttributeNames];
+}
+
+- (id)accessibilityAttributeValue:(NSString *)attribute forParameter:(id)parameter
+{
+   return [super accessibilityAttributeValue: attribute forParameter: parameter];
+}
+
+/* Acessibility action methods
+ */
+- (NSArray *)accessibilityActionNames
+{
+   // see comments in wxOSX_accessibilityActionNames
+   wxString unused;
+   wxAccStatus status = accessible->GetDefaultAction(number, &unused);
+   if (status == wxACC_OK)
+   {
+      return [NSArray arrayWithObject: NSAccessibilityPressAction];
+   }
+
+   if ([[self superclass] instancesRespondToSelector:
+        @selector(accessibilityActionNames)])
+      return [super accessibilityActionNames];
+   return [NSArray array];
+}
+
+- (NSString *)accessibilityActionDescription:(NSString *)action
+{
+   NSString *result = NSAccessibilityActionDescription(action);
+   if (result)
+      return result;
+
+   return [super accessibilityActionDescription: action];
+}
+
+- (void)accessibilityPerformAction:(NSString *)action
+{
+   wxAccStatus status = accessible->DoDefaultAction(number);
+   if (status == wxACC_OK)
+      return;
+
+   [super accessibilityPerformAction: action];
+}
+
+/* Return YES if the UIElement doesn't show up to the outside world - i.e. its parent should return the UIElement's children as its own - cutting the UIElement out. E.g. NSControls are ignored when they are single-celled.
+ */
+- (BOOL)accessibilityIsIgnored
+{
+   return NO;
+}
+
+/* Returns the deepest descendant of the UIElement hierarchy that contains the point. You can assume the point has already been determined to lie within the receiver. Override this method to do deeper hit testing within a UIElement - e.g. a NSMatrix would test its cells. The point is bottom-left relative screen coordinates.
+ */
+- (id)accessibilityHitTest:(NSPoint)point
+{
+   return [super accessibilityHitTest: point];
+}
+
+/* Returns the UI Element that has the focus. You can assume that the search for the focus has already been narrowed down to the reciever. Override this method to do a deeper search with a UIElement - e.g. a NSMatrix would determine if one of its cells has the focus.
+ */
+- (id)accessibilityFocusedUIElement
+{
+   return [super accessibilityFocusedUIElement];
+}
+
+
+/*  Optional methods to improve performance of accessible objects with large numbers of children or large numbers of UI Elements returned from attributes that return an array (selected children, or visible children, for instance).  The default implementation for these operations will call -accessibilityAttributeValue: to retrieve the entire array of values, and then perform the appropriate operation.  If these methods are implemented, they will be used instead.  For accessibility objects with many children, the results to these methods can sometimes be calculated without generating the entire array of children which can improve performance.
+ */
+
+/* Given an accessibility child of an object, return the index of that child in the parent.
+ */
+- (NSUInteger)accessibilityIndexOfChild:(id)child
+{
+   return swxNSAccessibilityChildrenAttribute
+      .IndexOfValue(self, *accessible, number, child);
+}
+
+/* Return the count of an accessibility array attribute.
+ */
+- (NSUInteger)accessibilityArrayAttributeCount:(NSString *)attribute
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   const wxNSAccessibilityAttribute *pAttribute =
+   findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+   {
+      const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+         dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+      if (pArrayAttribute)
+      {
+         return pArrayAttribute->GetCount(self, *accessible, number);
+      }
+   }
+
+   return [super accessibilityArrayAttributeCount: attribute];
+}
+
+/* Return a subarray of values of an accessibility array attribute.  Note this method does not take a range.  The max count is the maximum desired number of items requested by an accessibility client.  This number may be beyond the bounds of your array.
+ */
+- (NSArray *)accessibilityArrayAttributeValues:(NSString *)attribute
+                                         index:(NSUInteger)index
+                                      maxCount:(NSUInteger)maxCount
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   const wxNSAccessibilityAttribute *pAttribute =
+   findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+   {
+      const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+      dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+      if (pArrayAttribute)
+      {
+         return pArrayAttribute->GetValues
+            (self, *accessible, number, index, maxCount);
+      }
+   }
+
+   return [super accessibilityArrayAttributeValues: attribute
+                                             index: index
+                                          maxCount: maxCount];
+}
+
+@end
+
+void wxOSXCocoaClassAddWXAccessibilityMethods(Class c)
+{
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityAttributeNames), (IMP) wxOSX_accessibilityAttributeNames, "@@:" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityAttributeValue:), (IMP) wxOSX_accessibilityAttributeValue, "@@:@" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityIsAttributeSettable:), (IMP) wxOSX_accessibilityIsAttributeSettable, "c@:@" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilitySetValue:forAttribute:), (IMP) wxOSX_accessibilitySetValue_forAttribute, "v@:@@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityParameterizedAttributeNames), (IMP) wxOSX_accessibilityParameterizedAttributeNames, "@@:" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityAttributeValue:forParameter:), (IMP) wxOSX_accessibilityAttributeValue_forParameter, "@@:@@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityActionNames), (IMP) wxOSX_accessibilityActionNames, "@@:" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityActionDescription:), (IMP) wxOSX_accessibilityActionDescription, "@@:@" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityPerformAction:), (IMP) wxOSX_accessibilityPerformAction, "v@:@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityIsIgnored), (IMP) wxOSX_accessibilityIsIgnored, "c@:" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityHitTest:), (IMP) wxOSX_accessibilityHitTest, "@@:{_NSPoint=ff}" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityFocusedUIElement), (IMP) wxOSX_accessibilityFocusedUIElement, "@@:" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityIndexOfChild:), (IMP) wxOSX_accessibilityIndexOfChild, "I@:@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityArrayAttributeCount:), (IMP) wxOSX_accessibilityArrayAttributeCount, "I@:@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityArrayAttributeValues:index:maxCount:), (IMP) wxOSX_accessibilityArrayAttributeValues_index_maxCount, "@@:@II" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilitySetOverrideValue:forAttribute:), (IMP) wxOSX_accessibilitySetOverrideValue_forAttribute, "c@:@@" )
+}
+
+// static
+void wxAccessible::NotifyEvent
+(int eventType, wxWindow* window, wxAccObject objectType, int objectId)
+{
+#if 0
+   // Leftover NSAccessibility notifications that didn't correspond
+
+   /* Focus notifications
+    */
+NSAccessibilityMainWindowChangedNotification;
+
+   /* Application notifications
+    */
+NSAccessibilityApplicationActivatedNotification;
+NSAccessibilityApplicationDeactivatedNotification;
+NSAccessibilityApplicationHiddenNotification;
+NSAccessibilityApplicationShownNotification;
+
+   /* Window notifications
+    */
+NSAccessibilityWindowCreatedNotification;
+NSAccessibilityWindowDeminiaturizedNotification;
+
+   /* Drawer & sheet notifications
+    */
+NSAccessibilityDrawerCreatedNotification;
+NSAccessibilitySheetCreatedNotification;
+
+   /* Misc notifications
+    */
+NSAccessibilityHelpTagCreatedNotification	;
+NSAccessibilityRowCountChangedNotification;
+
+NSAccessibilityRowExpandedNotification	;
+NSAccessibilityRowCollapsedNotification	;
+
+   /* Cell-table notifications
+    */
+
+   /* Layout area notifications
+    */
+NSAccessibilityUnitsChangedNotification ;
+
+#endif
+
+   enum { maxNotifications = 6 };
+   NSString *notifications[maxNotifications];
+   for(unsigned ii = 0; ii < maxNotifications; ++ii)
+      notifications[ii] = NULL;
+
+   NSString *& notification = notifications[0];
+   NSString *& notification2 = notifications[1];
+
+   switch (eventType)
+   {
+      case wxACC_EVENT_SYSTEM_MOVESIZEEND:
+         notification = NSAccessibilityWindowResizedNotification;
+         break;
+
+      case wxACC_EVENT_SYSTEM_MINIMIZEEND:
+         notification = NSAccessibilityWindowMiniaturizedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_CREATE:
+         notification = NSAccessibilityCreatedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_DESTROY:
+         notification = NSAccessibilityUIElementDestroyedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_NAMECHANGE:
+         notification = NSAccessibilityTitleChangedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_VALUECHANGE:
+         notification = NSAccessibilityValueChangedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_LOCATIONCHANGE:
+         notification = NSAccessibilityMovedNotification;
+         notification2 = NSAccessibilityResizedNotification;
+         break;
+
+      case wxACC_EVENT_SYSTEM_DRAGDROPEND:
+         // Not sure if this is right...
+         if (objectType == wxOBJID_WINDOW)
+            notification = NSAccessibilityWindowMovedNotification;
+         else
+            notification = NSAccessibilityMovedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_FOCUS:
+         // Not sure if this is right...
+         if (objectType == wxOBJID_WINDOW)
+            notification = NSAccessibilityFocusedWindowChangedNotification;
+         else
+            notification = NSAccessibilityFocusedUIElementChangedNotification;
+         break;
+
+         // Selection notifications... quite a mismatch between the
+         // wxWidgets interface and the NS interface.  Just make lots
+         // of notifications to cover the possibilities.
+      case wxACC_EVENT_OBJECT_SELECTION:
+      case wxACC_EVENT_OBJECT_SELECTIONADD:
+      case wxACC_EVENT_OBJECT_SELECTIONREMOVE:
+      case wxACC_EVENT_OBJECT_SELECTIONWITHIN:
+         notifications[0] = NSAccessibilitySelectedTextChangedNotification;
+         notifications[1] = NSAccessibilitySelectedChildrenChangedNotification;
+         notifications[2] = NSAccessibilitySelectedRowsChangedNotification;
+         notifications[3] = NSAccessibilitySelectedColumnsChangedNotification;
+         notifications[4] = NSAccessibilitySelectedCellsChangedNotification;
+         // notifications[5] = NSAccessibilitySelectedChildrenMovedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_REORDER:
+      case wxACC_EVENT_SYSTEM_SCROLLINGEND:
+         notification = NSAccessibilitySelectedChildrenMovedNotification;
+         // maybe?
+         break;
+
+      case wxACC_EVENT_OBJECT_STATECHANGE:
+      case wxACC_EVENT_OBJECT_DESCRIPTIONCHANGE:
+      case wxACC_EVENT_OBJECT_PARENTCHANGE:
+      case wxACC_EVENT_OBJECT_HELPCHANGE:
+      case wxACC_EVENT_OBJECT_DEFACTIONCHANGE:
+      case wxACC_EVENT_OBJECT_ACCELERATORCHANGE:
+         if (objectType == wxOBJID_CLIENT)
+         {
+            notification = NSAccessibilitySelectedChildrenChangedNotification;
+            // maybe?
+            break;
+         }
+         else
+            return;
+
+      case wxACC_EVENT_SYSTEM_SOUND:
+      case wxACC_EVENT_SYSTEM_ALERT:
+      case wxACC_EVENT_SYSTEM_FOREGROUND:
+      case wxACC_EVENT_SYSTEM_MENUSTART:
+      case wxACC_EVENT_SYSTEM_MENUEND:
+      case wxACC_EVENT_SYSTEM_MENUPOPUPSTART:
+      case wxACC_EVENT_SYSTEM_MENUPOPUPEND:
+      case wxACC_EVENT_SYSTEM_CAPTURESTART:
+      case wxACC_EVENT_SYSTEM_CAPTUREEND:
+      case wxACC_EVENT_SYSTEM_MOVESIZESTART:
+
+      case wxACC_EVENT_SYSTEM_CONTEXTHELPSTART:
+      case wxACC_EVENT_SYSTEM_CONTEXTHELPEND:
+      case wxACC_EVENT_SYSTEM_DRAGDROPSTART:
+
+      case wxACC_EVENT_SYSTEM_DIALOGSTART:
+      case wxACC_EVENT_SYSTEM_DIALOGEND:
+      case wxACC_EVENT_SYSTEM_SCROLLINGSTART:
+
+      case wxACC_EVENT_SYSTEM_SWITCHSTART:
+      case wxACC_EVENT_SYSTEM_SWITCHEND:
+      case wxACC_EVENT_SYSTEM_MINIMIZESTART:
+
+      case wxACC_EVENT_OBJECT_SHOW:
+      case wxACC_EVENT_OBJECT_HIDE:
+
+      default:
+         // no equivalents
+      return;
+   }
+
+   id element = nil;
+   if (objectType == wxOBJID_CLIENT)
+   {
+      wxAccessible *pAccessible = window->GetAccessible();
+      if (!pAccessible)
+         return;
+
+      wxAccessible *child = NULL;
+      wxAccStatus status = pAccessible->GetChild(objectId, &child);
+      element = GetUIElement(*pAccessible, objectId, child);
+   }
+   else
+      element = window->GetPeer()->GetWXWidget();
+
+   if (!element)
+      return;
+
+   for(unsigned ii = 0; ii < maxNotifications; ++ii)
+   {
+      NSString *notification = notifications[ii];
+      if (!notification)
+         break;
+      NSAccessibilityPostNotification(element, notification);
+   }
+}
+
 void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
 {
 
@@ -2455,6 +4329,8 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
     {
 #endif
 
+    wxOSX_CLASS_ADD_METHOD(c, @selector(stringValue), (IMP) wxOSX_stringValue, "@@:");
+
     wxOSX_CLASS_ADD_METHOD(c, @selector(mouseDown:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(rightMouseDown:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(otherMouseDown:), (IMP) wxOSX_mouseEvent, "v@:@" )
@@ -2468,7 +4344,7 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
     wxOSX_CLASS_ADD_METHOD(c, @selector(mouseDragged:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(rightMouseDragged:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(otherMouseDragged:), (IMP) wxOSX_mouseEvent, "v@:@" )
-    
+
     wxOSX_CLASS_ADD_METHOD(c, @selector(acceptsFirstMouse:), (IMP) wxOSX_acceptsFirstMouse, "v@:@" )
 
     wxOSX_CLASS_ADD_METHOD(c, @selector(scrollWheel:), (IMP) wxOSX_mouseEvent, "v@:@" )
@@ -2494,7 +4370,7 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
 #if !wxOSX_USE_NATIVE_FLIPPED
     wxOSX_CLASS_ADD_METHOD(c, @selector(isFlipped), (IMP) wxOSX_isFlipped, "c@:" )
 #endif
-        
+
     if ( !(skipFlags & wxOSXSKIP_DRAW) )
         wxOSX_CLASS_ADD_METHOD(c, @selector(drawRect:), (IMP) wxOSX_drawRect, "v@:{_NSRect={_NSPoint=ff}{_NSSize=ff}}" )
 
@@ -2508,6 +4384,8 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
     wxOSX_CLASS_ADD_METHOD(c, @selector(performDragOperation:), (IMP) wxOSX_performDragOperation, "c@:@" )
 #endif
 
+    wxOSXCocoaClassAddWXAccessibilityMethods(c);
+
 #if OBJC_API_VERSION < 2
     } ;
     static int method_count = WXSIZEOF( wxmethods );
@@ -2534,11 +4412,11 @@ wxWidgetImpl( peer, flags )
 {
     Init();
     m_osxView = w;
-    
+
     // check if the user wants to create the control initially hidden
     if ( !peer->IsShown() )
         SetVisibility(false);
-    
+
     // gc aware handling
     if ( m_osxView )
         CFRetain(m_osxView);
@@ -2565,7 +4443,7 @@ wxWidgetCocoaImpl::~wxWidgetCocoaImpl()
 {
     if ( GetWXPeer() && GetWXPeer()->IsFrozen() )
         SetDrawingEnabled(true);
-    
+
     RemoveAssociations( this );
 
     if ( !IsRootControl() )
@@ -2591,7 +4469,7 @@ bool wxWidgetCocoaImpl::IsVisible() const
 void wxWidgetCocoaImpl::SetVisibility( bool visible )
 {
     [m_osxView setHidden:(visible ? NO:YES)];
-    
+
     // trigger redraw upon shown for layer-backed views
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_14
     if ( WX_IS_MACOS_AVAILABLE(10, 14 ) )
@@ -3001,7 +4879,7 @@ void wxWidgetCocoaImpl::GetPosition( int &x, int &y ) const
     wxRect r = wxFromNSRect( [m_osxView superview], [m_osxView frame] );
     x = r.GetLeft();
     y = r.GetTop();
-    
+
     // under Cocoa we might have a contentView in the wxParent to which we have to
     // adjust the coordinates
     wxWindowMac* parent = GetWXPeer()->GetParent();
@@ -3052,7 +4930,7 @@ void wxWidgetCocoaImpl::GetContentArea( int&left, int &top, int &width, int &hei
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_14
 namespace
 {
-    
+
 void SetSubviewsNeedDisplay( NSView *view )
 {
     for ( NSView *sub in view.subviews )
@@ -3064,7 +4942,7 @@ void SetSubviewsNeedDisplay( NSView *view )
         SetSubviewsNeedDisplay(sub);
     }
 }
-    
+
 }
 #endif
 
@@ -3123,12 +5001,12 @@ bool wxWidgetCocoaImpl::SetFocus()
 void wxWidgetCocoaImpl::SetDropTarget(wxDropTarget* target)
 {
     [m_osxView unregisterDraggedTypes];
-    
+
     if ( target == NULL )
         return;
-    
+
     wxDataObject* dobj = target->GetDataObject();
-    
+
     if( dobj )
     {
         CFMutableArrayRef typesarray = CFArrayCreateMutable(kCFAllocatorDefault,0,&kCFTypeArrayCallBacks);
@@ -3157,7 +5035,7 @@ void wxWidgetCocoaImpl::Embed( wxWidgetImpl *parent )
     NSView* container = parent->GetWXWidget() ;
     wxASSERT_MSG( container != NULL , wxT("No valid mac container control") ) ;
     [container addSubview:m_osxView];
-    
+
     // User panes will be frozen elsewhere
     if( m_wxPeer->IsFrozen() && !IsUserPane() )
         SetDrawingEnabled(false);
@@ -3185,14 +5063,14 @@ void wxWidgetCocoaImpl::SetBackgroundColour( const wxColour &col )
 bool wxWidgetCocoaImpl::SetBackgroundStyle( wxBackgroundStyle style )
 {
     BOOL opaque = ( style == wxBG_STYLE_PAINT );
-    
+
     if ( [m_osxView respondsToSelector:@selector(setOpaque:) ] )
     {
         [m_osxView setOpaque: opaque];
         if ( style == wxBG_STYLE_TRANSPARENT )
             [m_osxView setBackgroundColor:[NSColor clearColor]];
     }
-    
+
     return true ;
 }
 
@@ -3248,7 +5126,7 @@ void wxWidgetCocoaImpl::SetLabel( const wxString& title, wxFontEncoding encoding
             [attrString endEditing];
 
             [(id)m_osxView setAttributedTitle:attrString];
-            
+
             [attrString release];
 
             return;
@@ -3479,7 +5357,7 @@ void wxWidgetCocoaImpl::SetControlSize( wxWindowVariant variant )
     if ( [m_osxView isKindOfClass:[NSScrollView class] ] )
     {
         NSView* targetView = [(NSScrollView*) m_osxView documentView];
-    
+
         if ( [targetView respondsToSelector:@selector(setControlSize:)] )
             [targetView setControlSize:size];
         else if ([targetView respondsToSelector:@selector(cell)])
@@ -3514,7 +5392,7 @@ void wxWidgetCocoaImpl::SetToolTip(wxToolTip* tooltip)
         wxCFStringRef cf( tooltip->GetTip() , m_wxPeer->GetFont().GetEncoding() );
         [m_osxView setToolTip: cf.AsNSString()];
     }
-    else 
+    else
     {
         [m_osxView setToolTip:nil];
     }
@@ -3533,7 +5411,7 @@ void wxWidgetCocoaImpl::InstallEventHandler( WXWidget control )
         }
         else
             [c setAction: @selector(controlAction:)];
-        
+
         if ([c respondsToSelector:@selector(setDoubleAction:)])
         {
             [c setDoubleAction: @selector(controlDoubleAction:)];
@@ -3571,7 +5449,7 @@ bool wxWidgetCocoaImpl::EnableTouchEvents(int eventsMask)
                     new wxCocoaGesturesImpl(this, m_osxView, eventsMask)
                 );
 #endif
-                
+
                 [m_osxView setAcceptsTouchEvents:YES];
             }
 
@@ -3597,12 +5475,12 @@ bool wxWidgetCocoaImpl::DoHandleCharEvent(NSEvent *event, NSString *text)
               ++it )
         {
             wxKeyEvent wxevent(wxEVT_CHAR);
-            
+
             // if we have exactly one character resulting from the event, then
             // set the corresponding modifiers and raw data from the nsevent
             // otherwise leave these at defaults, as they probably would be incorrect
             // anyway (IME input)
-            
+
             if ( event != nil && length == 1)
             {
                 SetupKeyEvent(wxevent,event,text);
@@ -3618,14 +5496,14 @@ bool wxWidgetCocoaImpl::DoHandleCharEvent(NSEvent *event, NSString *text)
                 wxevent.m_uniChar = aunichar;
 #endif
                 wxevent.m_keyCode = aunichar < 0x80 ? aunichar : WXK_NONE;
-                
+
                 wxevent.SetEventObject(peer);
                 wxevent.SetId(peer->GetId());
 
                 if ( event )
                     wxevent.SetTimestamp( (int)([event timestamp] * 1000) ) ;
             }
-            
+
             result = peer->OSXHandleKeyEvent(wxevent) || result;
         }
     }
@@ -3722,7 +5600,7 @@ void wxWidgetCocoaImpl::DoNotifyFocusSet()
     NSResponder* responder = wxNonOwnedWindowCocoaImpl::GetFormerFirstResponder();
     NSView* otherView = wxOSXGetViewFromResponder(responder);
     wxWidgetImpl* otherWindow = FindFromWXWidget(otherView);
-    
+
     // It doesn't make sense to notify about the focus set if it's the same
     // control in the end, and just a different subview
     if ( otherWindow != this )
@@ -3734,7 +5612,7 @@ void wxWidgetCocoaImpl::DoNotifyFocusLost()
     NSResponder * responder = wxNonOwnedWindowCocoaImpl::GetNextFirstResponder();
     NSView* otherView = wxOSXGetViewFromResponder(responder);
     wxWidgetImpl* otherWindow = FindBestFromWXWidget(otherView);
-    
+
     // It doesn't make sense to notify about the loss of focus if it's the same
     // control in the end, and just a different subview
     if ( otherWindow != this )
@@ -3790,8 +5668,8 @@ void wxWidgetCocoaImpl::SetCursor(const wxCursor& cursor)
         NSRect location = NSZeroRect;
         location.origin = [NSEvent mouseLocation];
         location = [[m_osxView window] convertRectFromScreen:location];
-        NSPoint locationInView = [m_osxView convertPoint:location.origin fromView:nil];        
-        
+        NSPoint locationInView = [m_osxView convertPoint:location.origin fromView:nil];
+
         if( NSMouseInRect(locationInView, [m_osxView bounds], YES) )
         {
             [(NSCursor*)cursor.GetHCURSOR() set];
@@ -3853,7 +5731,7 @@ wxWidgetImpl* wxWidgetImpl::CreateUserPane( wxWindowMac* wxpeer, wxWindowMac* WX
 wxWidgetImpl* wxWidgetImpl::CreateContentView( wxNonOwnedWindow* now )
 {
     NSWindow* tlw = now->GetWXWindow();
-    
+
     wxWidgetCocoaImpl* c = NULL;
     if ( now->IsNativeWindowWrapper() )
     {
diff --git src/common/filefn.cpp src/common/filefn.cpp
index 51ac27ade9c..ffe647acee2 100644
--- src/common/filefn.cpp
+++ src/common/filefn.cpp
@@ -1116,7 +1116,8 @@ wxCopyFile (const wxString& file1, const wxString& file2, bool overwrite)
 bool
 wxRenameFile(const wxString& file1, const wxString& file2, bool overwrite)
 {
-    if ( !overwrite && wxFileExists(file2) )
+    bool exists = wxFileExists(file2);
+    if ( !overwrite && exists )
     {
         wxLogSysError
         (
@@ -1128,8 +1129,21 @@ wxRenameFile(const wxString& file1, const wxString& file2, bool overwrite)
     }
 
     // Normal system call
-  if ( wxRename (file1, file2) == 0 )
-    return true;
+    //
+    // For explanation, see:  (warning...based mostly on observed behavior)
+    //   http://bugzilla.audacityteam.org/show_bug.cgi?id=1266
+    //   https://github.com/audacity/audacity/pull/94
+  unsigned long doserrno = 0;
+  for (int i = 0; i < 2000; i++)
+  {
+    if ( wxRename (file1, file2) == 0 )
+	  return true;
+    unsigned long doserrno;
+    _get_doserrno(&doserrno);
+    if (doserrno != ERROR_ACCESS_DENIED && (doserrno != ERROR_ALREADY_EXISTS || exists))
+        break;
+    wxMilliSleep(1);
+  }
 
   // Try to copy
   if (wxCopyFile(file1, file2, overwrite)) {

From ecfb5952cac7a57b58e46283bf649fbdfb2ae537 Mon Sep 17 00:00:00 2001
From: James Crook <james.k.crook@gmail.com>
Date: Sat, 31 Dec 2016 17:04:49 +0000
Subject: [PATCH 04/25] Retry file renaming on Windows only.

It won't work on Mac anyway because of use of _get_doserrno()
---
 src/common/filefn.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git src/common/filefn.cpp src/common/filefn.cpp
index ffe647acee2..065962cde31 100644
--- src/common/filefn.cpp
+++ src/common/filefn.cpp
@@ -1128,6 +1128,11 @@ wxRenameFile(const wxString& file1, const wxString& file2, bool overwrite)
         return false;
     }
 
+// This Audacity specific fixup should only be for Windows.
+#if !defined( __WINDOWS__ )
+  if ( wxRename (file1, file2) == 0 )
+    return true;
+#else 
     // Normal system call
     //
     // For explanation, see:  (warning...based mostly on observed behavior)
@@ -1137,13 +1142,14 @@ wxRenameFile(const wxString& file1, const wxString& file2, bool overwrite)
   for (int i = 0; i < 2000; i++)
   {
     if ( wxRename (file1, file2) == 0 )
-	  return true;
+      return true;
     unsigned long doserrno;
     _get_doserrno(&doserrno);
     if (doserrno != ERROR_ACCESS_DENIED && (doserrno != ERROR_ALREADY_EXISTS || exists))
         break;
     wxMilliSleep(1);
   }
+#endif
 
   // Try to copy
   if (wxCopyFile(file1, file2, overwrite)) {

From 09dde48dbbf022f80e9f1ebb600469c973a4f382 Mon Sep 17 00:00:00 2001
From: Paul Licameli <paul.licameli@audacityteam.org>
Date: Tue, 19 Jun 2018 08:33:20 -0400
Subject: [PATCH 05/25] stub virtual functions needed to compile for Mac with
 accessibility

---
 include/wx/osx/dvrenderers.h | 22 ++++++++++++++++++++++
 1 file changed, 22 insertions(+)

diff --git include/wx/osx/dvrenderers.h include/wx/osx/dvrenderers.h
index 1b8231eebf8fba7cde810774a128165812199dd1..37a193eea23f655d31ac032f6552fa8b27ad9fda 100644
--- include/wx/osx/dvrenderers.h
+++ include/wx/osx/dvrenderers.h
@@ -87,6 +87,9 @@ public:
     virtual void OSXOnCellChanged(NSObject *value,
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
+#if wxUSE_ACCESSIBILITY
+      virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
 
 private:
 #if wxUSE_MARKUP && wxOSX_USE_COCOA
@@ -112,6 +115,10 @@ public:
 
     virtual bool MacRender() wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewBitmapRenderer);
 };
@@ -137,6 +144,10 @@ public:
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     wxArrayString m_choices;
 
@@ -160,6 +171,10 @@ public:
     virtual void OSXOnCellChanged(NSObject *value,
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
+
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
 };
 
 // ---------------------------------------------------------
@@ -180,6 +195,10 @@ public:
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewIconTextRenderer);
 };
@@ -206,6 +225,10 @@ public:
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     void DoInitButtonCell(int buttonType);
 
@@ -231,7 +254,9 @@ public:
     virtual void OSXOnCellChanged(NSObject *value,
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
-
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
 private:
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewProgressRenderer);
 };
@@ -255,6 +280,10 @@ public:
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewDateRenderer);
 };
diff --git include/wx/access.h include/wx/access.h
index 49489692094..ead3363859a 100644
--- include/wx/access.h
+++ include/wx/access.h
@@ -371,6 +371,20 @@ class WXDLLIMPEXP_CORE wxAccessibleBase : public wxObject
     #include "wx/msw/ole/access.h"
 #endif
 
+#if defined(__WXMAC__)
+
+class WXDLLIMPEXP_CORE wxAccessible : public wxAccessibleBase
+{
+public:
+   wxAccessible(wxWindow *win = NULL) : wxAccessibleBase(win) {}
+   virtual ~wxAccessible() {}
+
+   static void NotifyEvent
+   (int eventType, wxWindow* window, wxAccObject objectType, int objectId);
+};
+
+#endif
+
 #endif // wxUSE_ACCESSIBILITY
 
 #endif // _WX_ACCESSBASE_H_
diff --git include/wx/chkconf.h include/wx/chkconf.h
index 82bb132b8a352deacce1bc264ad95bec9f0b2f56..8811e8c299de4191d593da5b8e72d9da28da1c2c 100644
--- include/wx/chkconf.h
+++ include/wx/chkconf.h
@@ -1511,9 +1511,9 @@
  */
 #if wxUSE_GUI
 
-#if wxUSE_ACCESSIBILITY && !defined(__WXMSW__)
+#if wxUSE_ACCESSIBILITY && !( defined(__WXMSW__) || defined(__WXOSX_COCOA__) || defined(__APPLE__))
 #   ifdef wxABORT_ON_CONFIG_ERROR
-#       error "wxUSE_ACCESSIBILITY is currently only supported under wxMSW"
+#       error "wxUSE_ACCESSIBILITY is currently only supported under wxMSW or Cocoa"
 #   else
 #       undef wxUSE_ACCESSIBILITY
 #       define wxUSE_ACCESSIBILITY 0
diff --git setup.h.in setup.h.in
index fad308dc540..fec9a81f7a1 100644
--- setup.h.in
+++ setup.h.in
@@ -554,8 +554,8 @@
 
 #define wxUSE_DRAG_AND_DROP 0
 
-#ifdef __WXMSW__
-#define wxUSE_ACCESSIBILITY 0
+#if (defined (__WXMSW__) || defined(__WXOSX_COCOA__))
+#define wxUSE_ACCESSIBILITY 1
 #else
 #define wxUSE_ACCESSIBILITY 0
 #endif
diff --git build/cmake/options.cmake build/cmake/options.cmake
index b7703811ac933253fb0d2818d1464a8fbb665e2e..a8c922c740059442890809cf557ddc9f3dd55d48 100644
--- build/cmake/options.cmake
+++ build/cmake/options.cmake
@@ -411,6 +411,9 @@ if(WIN32)
     wx_option(wxUSE_WINRT "enable WinRT support" ${wxUSE_WINRT_DEFAULT})
     wx_option(wxUSE_ACCESSIBILITY "enable accessibility support")
 endif()
+if(APPLE)
+    wx_option(wxUSE_ACCESSIBILITY "enable accessibility support" ON)
+endif()
 
 # this one is not really MSW-specific but it exists mainly to be turned off
 # under MSW, it should be off by default on the other platforms
diff --git build/cmake/setup.cmake build/cmake/setup.cmake
index a102731af95aca1d6c489751e995607bfa70574e..d1bb2e193251afcba558f653ac1fb8326bd14ebd 100644
--- build/cmake/setup.cmake
+++ build/cmake/setup.cmake
@@ -672,6 +672,10 @@ check_type_size(ssize_t SSIZE_T)
 
 test_big_endian(WORDS_BIGENDIAN)
 
+if(APPLE)
+    # for audacity
+    set(wxUSE_ACCESSIBILITY ON)
+endif()
 configure_file(build/cmake/setup.h.in ${wxSETUP_HEADER_FILE})
 if(DEFINED wxSETUP_HEADER_FILE_DEBUG)
     # The debug version may be configured with different values in the future
diff --git src/gtk/dataview.cpp src/gtk/dataview.cpp
index eb2d5d9106e..17c68517b51 100644
--- src/gtk/dataview.cpp
+++ src/gtk/dataview.cpp
@@ -2629,6 +2629,7 @@ class wxDataViewCtrlDCImpl: public wxWindowDCImpl
         m_window = window;
 
         m_context = window->GTKGetPangoDefaultContext();
+        g_object_ref(m_context);
         m_layout = pango_layout_new( m_context );
         m_fontdesc = pango_font_description_copy(gtk_widget_get_style(widget)->font_desc);
 
diff --git src/gtk/dcclient.cpp src/gtk/dcclient.cpp
index 04d228e63c1..66f0e14f659 100644
--- src/gtk/dcclient.cpp
+++ src/gtk/dcclient.cpp
@@ -304,6 +304,7 @@ wxWindowDCImpl::wxWindowDCImpl( wxDC *owner, wxWindow *window ) :
     }
 
     m_context = window->GTKGetPangoDefaultContext();
+    g_object_ref(m_context);
     m_layout = pango_layout_new( m_context );
     m_fontdesc = pango_font_description_copy( widget->style->font_desc );
 
@@ -344,6 +345,8 @@ wxWindowDCImpl::~wxWindowDCImpl()
 {
     Destroy();
 
+    if (m_context)
+        g_object_unref(m_context);
     if (m_layout)
         g_object_unref (m_layout);
     if (m_fontdesc)
@@ -1539,6 +1542,10 @@ void wxWindowDCImpl::SetFont( const wxFont &font )
             // at least, and it doesn't hurt to do it.
             if (oldContext != m_context)
             {
+                g_object_ref(m_context);
+                if (oldContext)
+                    g_object_unref(oldContext);
+
                 if (m_layout)
                     g_object_unref (m_layout);
 
diff --git src/gtk/dcmemory.cpp src/gtk/dcmemory.cpp
index 9ac137d837a..f2e20da024c 100644
--- src/gtk/dcmemory.cpp
+++ src/gtk/dcmemory.cpp
@@ -40,7 +40,6 @@ wxMemoryDCImpl::wxMemoryDCImpl( wxMemoryDC *owner, wxDC *WXUNUSED(dc) )
 
 wxMemoryDCImpl::~wxMemoryDCImpl()
 {
-    g_object_unref(m_context);
 }
 
 void wxMemoryDCImpl::Init()
diff --git src/gtk/dcscreen.cpp src/gtk/dcscreen.cpp
index ea9f607ed92..1041e4fcca5 100644
--- src/gtk/dcscreen.cpp
+++ src/gtk/dcscreen.cpp
@@ -50,8 +50,6 @@ void wxScreenDCImpl::Init()
 
 wxScreenDCImpl::~wxScreenDCImpl()
 {
-    g_object_unref(m_context);
-
     gdk_gc_set_subwindow( m_penGC, GDK_CLIP_BY_CHILDREN );
     gdk_gc_set_subwindow( m_brushGC, GDK_CLIP_BY_CHILDREN );
     gdk_gc_set_subwindow( m_textGC, GDK_CLIP_BY_CHILDREN );

From a548d70cc782e652254f1e8ee5162864ab147b94 Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Sun, 10 Nov 2019 00:35:07 +0100
Subject: [PATCH 09/25] Initialize wxWindowDCImpl::m_window for hidden windows
 too

Ensure that we set m_window in case of early return from wxWindowDCImpl
ctor, so that using e.g. wxDC::GetSize() works for wxClientDC created
for windows that hadn't been realized yet.

It might be possible to avoid this early return completely as the
comment explaining why we're doing it seems to be out of date: our
SetBackground() doesn't call wxWindow::SetBackground() (and it would be
exceedingly strange if it did), but for now just the bug without
changing anything else.

Closes #18569.
---
 src/gtk/dcclient.cpp | 2 ++
 1 file changed, 2 insertions(+)

diff --git src/gtk/dcclient.cpp src/gtk/dcclient.cpp
index 66f0e14f659..d879b2f9e0b 100644
--- src/gtk/dcclient.cpp
+++ src/gtk/dcclient.cpp
@@ -314,6 +314,8 @@ wxWindowDCImpl::wxWindowDCImpl( wxDC *owner, wxWindow *window ) :
          // Don't report problems as per MSW.
          m_ok = true;
 
+         m_window = window;
+
          return;
     }
 

From 3c2a61d03694130ce8ba855959fd0770964fe56c Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Sun, 29 Dec 2019 01:40:28 +0100
Subject: [PATCH 10/25] Send kill focus events to modal dialogs earlier in
 wxGTK

Ensure that the dialog is still alive when it gets the kill focus event
for its child which had focus just before the dialog was closed (or any
other events generated by this child when it detects that it's losing
focus, such as wxEVT_SPINCTRL) by resetting focus when the dialog is
being hidden and not when it's being destroyed.

This makes the events order more consistent with wxMSW but also, most
importantly, safer, as wxEVT_KILL_FOCUS handlers could previously easily
reference the fields of an already half-destroyed wxDialog-derived
object by the time they were run during wxTopLevelWindowGTK destructor
execution.

Closes #18145.
---
 src/gtk/toplevel.cpp | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git src/gtk/toplevel.cpp src/gtk/toplevel.cpp
index 1d307883cbe..4faea74c255 100644
--- src/gtk/toplevel.cpp
+++ src/gtk/toplevel.cpp
@@ -1080,6 +1080,16 @@ bool wxTopLevelWindowGTK::Show( bool show )
 
     if (change && !show)
     {
+        // Generate wxEVT_KILL_FOCUS for the currently focused control
+        // immediately (i.e. without waiting until the window is destroyed and
+        // doing it from its dtor), as it could be too late to execute the
+        // handler for this event, or other events triggered by receiving it,
+        // by then because the wxTLW will have been half-destroyed by then.
+        if (GTK_IS_WINDOW(m_widget))
+        {
+            gtk_window_set_focus( GTK_WINDOW(m_widget), NULL );
+        }
+
         // make sure window has a non-default position, so when it is shown
         // again, it won't be repositioned by WM as if it were a new window
         // Note that this must be done _after_ the window is hidden.

From 85dbf5f732a2de4c969d8b18b0549b56d8a5c66a Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Wed, 15 Apr 2020 16:02:43 +0200
Subject: [PATCH 11/25] Don't set focus to unfocusable windows in wxGTK

Restore IsFocusable() check that was commented out, without any real
explanation, by c7bfb76a2c (A number of focus handling improvements:
Left clicking on a window only focuses the window if not processed.
wxControlContainer::SetFocus moved to wxControlContainerBase so that a
container now focuses the first child even on wxGTK. wxAuiBook is now a
container, need for correct navigation on wxGTK., 2007-08-18).

This is needed to avoid giving focus on click to the windows that
explicitly override AcceptsFocus() to return false, as e.g.
wxGridColLabelWindow and other wxGrid subwindow classes do. From the
user point of view, previously clicking on a grid row/column label just
disabled the user of arrow keys, which was very inconvenient (and didn't
happen under MSW).
---
 src/gtk/window.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git src/gtk/window.cpp src/gtk/window.cpp
index 14bbcf1d55f..16cbf06f6e6 100644
--- src/gtk/window.cpp
+++ src/gtk/window.cpp
@@ -1691,7 +1691,7 @@ gtk_window_button_press_callback( GtkWidget* WXUNUSED_IN_GTK3(widget),
         return TRUE;
 
     if ((event_type == wxEVT_LEFT_DOWN) && !win->IsOfStandardClass() &&
-        (gs_currentFocus != win) /* && win->IsFocusable() */)
+        (gs_currentFocus != win) && win->IsFocusable())
     {
         win->SetFocus();
     }

From cf08e4da3f48758d0649021b3114a6a531c0b9b9 Mon Sep 17 00:00:00 2001
From: Ilya Sinitsyn <the_siv@mail.ru>
Date: Tue, 28 Jan 2020 23:40:21 +0700
Subject: [PATCH 12/25] Fix making the wrong wxGrid cell visible when selecting
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We should make visible the cell of the corner of the current selected block.

Also fix names of the wxGrid::UpdateBlockBeingSelected parameters because
actually passed сщщквы are of any opposite selection block corners.
---
 include/wx/generic/grid.h | 12 ++++++------
 src/generic/grid.cpp      | 14 ++++++++------
 2 files changed, 14 insertions(+), 12 deletions(-)

diff --git include/wx/generic/grid.h include/wx/generic/grid.h
index 529523c4716..dc80ec17197 100644
--- include/wx/generic/grid.h
+++ include/wx/generic/grid.h
@@ -2249,13 +2249,13 @@ class WXDLLIMPEXP_CORE wxGrid : public wxScrolledCanvas
 
     // this function is called to extend the block being currently selected
     // from mouse and keyboard event handlers
-    void UpdateBlockBeingSelected(int topRow, int leftCol,
-                                  int bottomRow, int rightCol);
+    void UpdateBlockBeingSelected(int blockStartRow, int blockStartCol,
+                                  int blockEndRow, int blockEndCol);
 
-    void UpdateBlockBeingSelected(const wxGridCellCoords& topLeft,
-                        const wxGridCellCoords& bottomRight)
-        { UpdateBlockBeingSelected(topLeft.GetRow(), topLeft.GetCol(),
-                         bottomRight.GetRow(), bottomRight.GetCol()); }
+    void UpdateBlockBeingSelected(const wxGridCellCoords& blockStart,
+                                  const wxGridCellCoords& blockEnd)
+        { UpdateBlockBeingSelected(blockStart.GetRow(), blockStart.GetCol(),
+                                   blockEnd.GetRow(), blockEnd.GetCol()); }
 
     virtual bool ShouldScrollToChildOnFocus(wxWindow* WXUNUSED(win)) wxOVERRIDE
         { return false; }
diff --git src/generic/grid.cpp src/generic/grid.cpp
index 6bd351dd841..d1dcb3019ac 100644
--- src/generic/grid.cpp
+++ src/generic/grid.cpp
@@ -5731,11 +5731,16 @@ bool wxGrid::SetCurrentCell( const wxGridCellCoords& coords )
 }
 
 void
-wxGrid::UpdateBlockBeingSelected(int topRow, int leftCol,
-                                 int bottomRow, int rightCol)
+wxGrid::UpdateBlockBeingSelected(int blockStartRow, int blockStartCol,
+                                 int blockEndRow, int blockEndCol)
 {
+    m_selectedBlockCorner = wxGridCellCoords(blockEndRow, blockEndCol);
     MakeCellVisible(m_selectedBlockCorner);
-    m_selectedBlockCorner = wxGridCellCoords(bottomRow, rightCol);
+
+    int topRow = wxMin(blockStartRow, blockEndRow);
+    int leftCol = wxMin(blockStartCol, blockEndCol);
+    int bottomRow = wxMax(blockStartRow, blockEndRow);
+    int rightCol = wxMax(blockStartCol, blockEndCol);
 
     if ( m_selection )
     {
@@ -5773,9 +5778,6 @@ wxGrid::UpdateBlockBeingSelected(int topRow, int leftCol,
         }
     }
 
-    EnsureFirstLessThanSecond(topRow, bottomRow);
-    EnsureFirstLessThanSecond(leftCol, rightCol);
-
     wxGridCellCoords updateTopLeft = wxGridCellCoords(topRow, leftCol),
                      updateBottomRight = wxGridCellCoords(bottomRow, rightCol);
 

From f13a101458008092d33716c1553448b0041c5eda Mon Sep 17 00:00:00 2001
From: Ilya Sinitsyn <the_siv@mail.ru>
Date: Tue, 28 Jan 2020 23:53:26 +0700
Subject: [PATCH 13/25] Test wxGrid scrolling when selecting cells.

---
 tests/controls/gridtest.cpp | 26 ++++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git tests/controls/gridtest.cpp tests/controls/gridtest.cpp
index cadc1103924..e765c0ceaca 100644
--- tests/controls/gridtest.cpp
+++ tests/controls/gridtest.cpp
@@ -51,6 +51,7 @@ class GridTestCase : public CppUnit::TestCase
         WXUISIM_TEST( RangeSelect );
         CPPUNIT_TEST( Cursor );
         CPPUNIT_TEST( Selection );
+        CPPUNIT_TEST( ScrollWhenSelect );
         CPPUNIT_TEST( AddRowCol );
         CPPUNIT_TEST( DeleteAndAddRowCol );
         CPPUNIT_TEST( ColumnOrder );
@@ -91,6 +92,7 @@ class GridTestCase : public CppUnit::TestCase
     void RangeSelect();
     void Cursor();
     void Selection();
+    void ScrollWhenSelect();
     void AddRowCol();
     void DeleteAndAddRowCol();
     void ColumnOrder();
@@ -570,6 +572,30 @@ void GridTestCase::Selection()
     CPPUNIT_ASSERT(!m_grid->IsInSelection(3, 0));
 }
 
+void GridTestCase::ScrollWhenSelect()
+{
+    m_grid->AppendCols(10);
+
+    REQUIRE( m_grid->GetGridCursorCol() == 0 );
+    REQUIRE( m_grid->GetGridCursorRow() == 0 );
+    REQUIRE( m_grid->IsVisible(0, 0) );
+    REQUIRE( !m_grid->IsVisible(0, 4) );
+
+    for ( int i = 0; i < 4; ++i )
+    {
+        m_grid->MoveCursorRight(true);
+    }
+    CHECK( m_grid->IsVisible(0, 4) );
+
+    m_grid->ClearSelection();
+    m_grid->SetGridCursor(1, 1);
+    for ( int i = 0; i < 5; ++i )
+    {
+        m_grid->MoveCursorDown(true);
+    }
+    CHECK( m_grid->IsVisible(6, 1) );
+}
+
 void GridTestCase::AddRowCol()
 {
     CPPUNIT_ASSERT_EQUAL(10, m_grid->GetNumberRows());

From 076675eccf89e6d24a65204c60798184a1cf2e62 Mon Sep 17 00:00:00 2001
From: Ilya Sinitsyn <the_siv@mail.ru>
Date: Tue, 28 Jan 2020 01:37:12 +0700
Subject: [PATCH 14/25] Fix wxGrid Home and End keys handling

Take into account that rows and columns may be hidden and columns also can be
reordered.
---
 src/generic/grid.cpp | 62 +++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 56 insertions(+), 6 deletions(-)

diff --git src/generic/grid.cpp src/generic/grid.cpp
index d1dcb3019ac..d844a1f02bb 100644
--- src/generic/grid.cpp
+++ src/generic/grid.cpp
@@ -5475,15 +5475,65 @@ void wxGrid::OnKeyDown( wxKeyEvent& event )
                 break;
 
             case WXK_HOME:
-                GoToCell(event.ControlDown() ? 0
-                                             : m_currentCellCoords.GetRow(),
-                         0);
+                {
+                    if ( m_currentCellCoords == wxGridNoCellCoords )
+                        break;
+
+                    int row = m_currentCellCoords.GetRow();
+                    if ( event.ControlDown() )
+                    {
+                        row = 0;
+
+                        // Find visible row.
+                        for ( ; row < m_numRows; ++row )
+                        {
+                            if ( IsRowShown(row) )
+                                break;
+                        }
+                    }
+
+                    int col = 0;
+                    // Find visible column.
+                    for ( ; col < m_numCols; ++col )
+                    {
+                        if ( IsColShown(GetColAt(col)) )
+                            break;
+                    }
+
+                    ClearSelection();
+                    GoToCell(row, GetColAt(col));
+                }
                 break;
 
             case WXK_END:
-                GoToCell(event.ControlDown() ? m_numRows - 1
-                                             : m_currentCellCoords.GetRow(),
-                         m_numCols - 1);
+                {
+                    if ( m_currentCellCoords == wxGridNoCellCoords )
+                        break;
+
+                    int row = m_currentCellCoords.GetRow();
+                    if ( event.ControlDown() )
+                    {
+                        row = m_numRows - 1;
+
+                        // Find visible row.
+                        for ( ; row >= 0; --row )
+                        {
+                            if ( IsRowShown(row) )
+                                break;
+                        }
+                    }
+
+                    int col = m_numCols - 1;
+                    // Find visible column.
+                    for ( ; col >= 0; --col )
+                    {
+                        if ( IsColShown(GetColAt(col)) )
+                            break;
+                    }
+
+                    ClearSelection();
+                    GoToCell(row, GetColAt(col));
+                }
                 break;
 
             case WXK_PAGEUP:

From a2d7c7210b969defc0ba5615c5e755ccb109c79b Mon Sep 17 00:00:00 2001
From: Ilya Sinitsyn <the_siv@mail.ru>
Date: Wed, 29 Jan 2020 01:31:40 +0700
Subject: [PATCH 15/25] Test moving the grid cursor using End key for wxGrid

---
 tests/controls/gridtest.cpp | 32 ++++++++++++++++++++++++++++++++
 1 file changed, 32 insertions(+)

diff --git tests/controls/gridtest.cpp tests/controls/gridtest.cpp
index e765c0ceaca..65e65269098 100644
--- tests/controls/gridtest.cpp
+++ tests/controls/gridtest.cpp
@@ -52,6 +52,7 @@ class GridTestCase : public CppUnit::TestCase
         CPPUNIT_TEST( Cursor );
         CPPUNIT_TEST( Selection );
         CPPUNIT_TEST( ScrollWhenSelect );
+        WXUISIM_TEST( MoveGridCursorUsingEndKey );
         CPPUNIT_TEST( AddRowCol );
         CPPUNIT_TEST( DeleteAndAddRowCol );
         CPPUNIT_TEST( ColumnOrder );
@@ -93,6 +94,7 @@ class GridTestCase : public CppUnit::TestCase
     void Cursor();
     void Selection();
     void ScrollWhenSelect();
+    void MoveGridCursorUsingEndKey();
     void AddRowCol();
     void DeleteAndAddRowCol();
     void ColumnOrder();
@@ -596,6 +598,36 @@ void GridTestCase::ScrollWhenSelect()
     CHECK( m_grid->IsVisible(6, 1) );
 }
 
+void GridTestCase::MoveGridCursorUsingEndKey()
+{
+#if wxUSE_UIACTIONSIMULATOR
+    wxUIActionSimulator sim;
+
+    m_grid->AppendCols(10);
+
+    REQUIRE( m_grid->GetGridCursorCol() == 0 );
+    REQUIRE( m_grid->GetGridCursorRow() == 0 );
+    REQUIRE( m_grid->IsVisible(0, 0) );
+
+    // Hide the last row.
+    m_grid->HideRow(9);
+    // Hide the last column.
+    m_grid->HideCol(11);
+    // Move the penult column.
+    m_grid->SetColPos(10, 5);
+
+    m_grid->SetFocus();
+
+    sim.KeyDown(WXK_END, wxMOD_CONTROL);
+    sim.KeyUp(WXK_END, wxMOD_CONTROL);
+    wxYield();
+
+    CHECK( m_grid->GetGridCursorRow() == 8 );
+    CHECK( m_grid->GetGridCursorCol() == 9 );
+    CHECK( m_grid->IsVisible(8, 9) );
+#endif
+}
+
 void GridTestCase::AddRowCol()
 {
     CPPUNIT_ASSERT_EQUAL(10, m_grid->GetNumberRows());

From 9076d9186cbf4b05669aa90bb1785a57aba8b9de Mon Sep 17 00:00:00 2001
From: Ilya Sinitsyn <the_siv@mail.ru>
Date: Tue, 28 Jan 2020 02:42:27 +0700
Subject: [PATCH 16/25] Implement wxGrid cells selection for Home and End keys

Select cells if Shift is pressed when handling Home and End keys
---
 src/generic/grid.cpp | 36 ++++++++++++++++++++++++++++++------
 1 file changed, 30 insertions(+), 6 deletions(-)

diff --git src/generic/grid.cpp src/generic/grid.cpp
index d844a1f02bb..373f053b0fe 100644
--- src/generic/grid.cpp
+++ src/generic/grid.cpp
@@ -5479,7 +5479,10 @@ void wxGrid::OnKeyDown( wxKeyEvent& event )
                     if ( m_currentCellCoords == wxGridNoCellCoords )
                         break;
 
-                    int row = m_currentCellCoords.GetRow();
+                    const bool useSelectedBlockCorner =
+                        event.ShiftDown() && m_selectedBlockCorner != wxGridNoCellCoords;
+                    int row = useSelectedBlockCorner ? m_selectedBlockCorner.GetRow()
+                                                     : m_currentCellCoords.GetRow();
                     if ( event.ControlDown() )
                     {
                         row = 0;
@@ -5500,8 +5503,17 @@ void wxGrid::OnKeyDown( wxKeyEvent& event )
                             break;
                     }
 
-                    ClearSelection();
-                    GoToCell(row, GetColAt(col));
+                    if ( event.ShiftDown() )
+                    {
+                        UpdateBlockBeingSelected(m_currentCellCoords,
+                                                 wxGridCellCoords(row, col));
+                        MakeCellVisible(row, col);
+                    }
+                    else
+                    {
+                        ClearSelection();
+                        GoToCell(row, GetColAt(col));
+                    }
                 }
                 break;
 
@@ -5510,7 +5522,10 @@ void wxGrid::OnKeyDown( wxKeyEvent& event )
                     if ( m_currentCellCoords == wxGridNoCellCoords )
                         break;
 
-                    int row = m_currentCellCoords.GetRow();
+                    const bool useSelectedBlockCorner =
+                        event.ShiftDown() && m_selectedBlockCorner != wxGridNoCellCoords;
+                    int row = useSelectedBlockCorner ? m_selectedBlockCorner.GetRow()
+                                                     : m_currentCellCoords.GetRow();
                     if ( event.ControlDown() )
                     {
                         row = m_numRows - 1;
@@ -5531,8 +5546,17 @@ void wxGrid::OnKeyDown( wxKeyEvent& event )
                             break;
                     }
 
-                    ClearSelection();
-                    GoToCell(row, GetColAt(col));
+                    if ( event.ShiftDown() )
+                    {
+                        UpdateBlockBeingSelected(m_currentCellCoords,
+                                                 wxGridCellCoords(row, col));
+                        MakeCellVisible(row, col);
+                    }
+                    else
+                    {
+                        ClearSelection();
+                        GoToCell(row, GetColAt(col));
+                    }
                 }
                 break;
 

From 751177dc2bc858b5389b63594f401800cfc9074d Mon Sep 17 00:00:00 2001
From: Ilya Sinitsyn <the_siv@mail.ru>
Date: Wed, 29 Jan 2020 01:49:51 +0700
Subject: [PATCH 17/25] Test wxGrid cells selection using End key

---
 tests/controls/gridtest.cpp | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git tests/controls/gridtest.cpp tests/controls/gridtest.cpp
index 65e65269098..2c7371f8000 100644
--- tests/controls/gridtest.cpp
+++ tests/controls/gridtest.cpp
@@ -53,6 +53,7 @@ class GridTestCase : public CppUnit::TestCase
         CPPUNIT_TEST( Selection );
         CPPUNIT_TEST( ScrollWhenSelect );
         WXUISIM_TEST( MoveGridCursorUsingEndKey );
+        WXUISIM_TEST( SelectUsingEndKey );
         CPPUNIT_TEST( AddRowCol );
         CPPUNIT_TEST( DeleteAndAddRowCol );
         CPPUNIT_TEST( ColumnOrder );
@@ -95,6 +96,7 @@ class GridTestCase : public CppUnit::TestCase
     void Selection();
     void ScrollWhenSelect();
     void MoveGridCursorUsingEndKey();
+    void SelectUsingEndKey();
     void AddRowCol();
     void DeleteAndAddRowCol();
     void ColumnOrder();
@@ -628,6 +630,38 @@ void GridTestCase::MoveGridCursorUsingEndKey()
 #endif
 }
 
+void GridTestCase::SelectUsingEndKey()
+{
+#if wxUSE_UIACTIONSIMULATOR
+    wxUIActionSimulator sim;
+
+    m_grid->AppendCols(10);
+
+    REQUIRE( m_grid->GetGridCursorCol() == 0 );
+    REQUIRE( m_grid->GetGridCursorRow() == 0 );
+    REQUIRE( m_grid->IsVisible(0, 0) );
+
+    m_grid->SetFocus();
+
+    sim.KeyDown(WXK_END, wxMOD_CONTROL | wxMOD_SHIFT);
+    sim.KeyUp(WXK_END, wxMOD_CONTROL | wxMOD_SHIFT);
+    wxYield();
+
+    wxGridCellCoordsArray topleft = m_grid->GetSelectionBlockTopLeft();
+    wxGridCellCoordsArray bottomright = m_grid->GetSelectionBlockBottomRight();
+
+    CHECK( topleft.Count() == 1 );
+    CHECK( bottomright.Count() == 1 );
+
+    CHECK( topleft.Item(0).GetCol() == 0 );
+    CHECK( topleft.Item(0).GetRow() == 0 );
+    CHECK( bottomright.Item(0).GetCol() == 11 );
+    CHECK( bottomright.Item(0).GetRow() == 9 );
+
+    CHECK( m_grid->IsVisible(8, 9) );
+#endif
+}
+
 void GridTestCase::AddRowCol()
 {
     CPPUNIT_ASSERT_EQUAL(10, m_grid->GetNumberRows());

From af8518a4b59ef400de18b2fe39676a832501dd0e Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Sat, 1 Feb 2020 01:57:04 +0100
Subject: [PATCH 18/25] Simplify check for current cell in Home/End handling
 code

Prefer to just test whether we have it instead of breaking out of the
case if we don't, this is slightly more straightforward.

No real changes.
---
 src/generic/grid.cpp | 8 ++------
 1 file changed, 2 insertions(+), 6 deletions(-)

diff --git src/generic/grid.cpp src/generic/grid.cpp
index 373f053b0fe..d9ecb2342a2 100644
--- src/generic/grid.cpp
+++ src/generic/grid.cpp
@@ -5475,10 +5475,8 @@ void wxGrid::OnKeyDown( wxKeyEvent& event )
                 break;
 
             case WXK_HOME:
+                if ( m_currentCellCoords != wxGridNoCellCoords )
                 {
-                    if ( m_currentCellCoords == wxGridNoCellCoords )
-                        break;
-
                     const bool useSelectedBlockCorner =
                         event.ShiftDown() && m_selectedBlockCorner != wxGridNoCellCoords;
                     int row = useSelectedBlockCorner ? m_selectedBlockCorner.GetRow()
@@ -5518,10 +5516,8 @@ void wxGrid::OnKeyDown( wxKeyEvent& event )
                 break;
 
             case WXK_END:
+                if ( m_currentCellCoords != wxGridNoCellCoords )
                 {
-                    if ( m_currentCellCoords == wxGridNoCellCoords )
-                        break;
-
                     const bool useSelectedBlockCorner =
                         event.ShiftDown() && m_selectedBlockCorner != wxGridNoCellCoords;
                     int row = useSelectedBlockCorner ? m_selectedBlockCorner.GetRow()

From 940070428857968d1c6db051232f25461675dd5d Mon Sep 17 00:00:00 2001
From: Vadim Zeitlin <vadim@wxwidgets.org>
Date: Sat, 1 Feb 2020 02:23:05 +0100
Subject: [PATCH 19/25] Merge WXK_HOME and WXK_END handling in a single case

There are more commonalities than differences between the handling of
these 2 keys and it's better to have a single version of this code.

No changes in behaviour.
---
 src/generic/grid.cpp | 91 +++++++++++++++++++++-----------------------
 1 file changed, 43 insertions(+), 48 deletions(-)

diff --git src/generic/grid.cpp src/generic/grid.cpp
index d9ecb2342a2..26fee334b36 100644
--- src/generic/grid.cpp
+++ src/generic/grid.cpp
@@ -5475,71 +5475,66 @@ void wxGrid::OnKeyDown( wxKeyEvent& event )
                 break;
 
             case WXK_HOME:
+            case WXK_END:
                 if ( m_currentCellCoords != wxGridNoCellCoords )
                 {
-                    const bool useSelectedBlockCorner =
-                        event.ShiftDown() && m_selectedBlockCorner != wxGridNoCellCoords;
-                    int row = useSelectedBlockCorner ? m_selectedBlockCorner.GetRow()
-                                                     : m_currentCellCoords.GetRow();
+                    const bool goToBeginning = event.GetKeyCode() == WXK_HOME;
+
+                    // Find the first or last visible row if we need to go to it
+                    // (without Control, we keep the current row).
+                    int row;
                     if ( event.ControlDown() )
                     {
-                        row = 0;
-
-                        // Find visible row.
-                        for ( ; row < m_numRows; ++row )
+                        if ( goToBeginning )
                         {
-                            if ( IsRowShown(row) )
-                                break;
+                            for ( row = 0; row < m_numRows; ++row )
+                            {
+                                if ( IsRowShown(row) )
+                                    break;
+                            }
+                        }
+                        else
+                        {
+                            for ( row = m_numRows - 1; row >= 0; --row )
+                            {
+                                if ( IsRowShown(row) )
+                                    break;
+                            }
                         }
-                    }
-
-                    int col = 0;
-                    // Find visible column.
-                    for ( ; col < m_numCols; ++col )
-                    {
-                        if ( IsColShown(GetColAt(col)) )
-                            break;
-                    }
-
-                    if ( event.ShiftDown() )
-                    {
-                        UpdateBlockBeingSelected(m_currentCellCoords,
-                                                 wxGridCellCoords(row, col));
-                        MakeCellVisible(row, col);
                     }
                     else
                     {
-                        ClearSelection();
-                        GoToCell(row, GetColAt(col));
+                        // If we're selecting, continue in the same row, which
+                        // may well be different from the one in which we
+                        // started selecting.
+                        if ( event.ShiftDown() &&
+                                m_selectedBlockCorner != wxGridNoCellCoords )
+                        {
+                            row = m_selectedBlockCorner.GetRow();
+                        }
+                        else // Just use the current row.
+                        {
+                            row = m_currentCellCoords.GetRow();
+                        }
                     }
-                }
-                break;
 
-            case WXK_END:
-                if ( m_currentCellCoords != wxGridNoCellCoords )
-                {
-                    const bool useSelectedBlockCorner =
-                        event.ShiftDown() && m_selectedBlockCorner != wxGridNoCellCoords;
-                    int row = useSelectedBlockCorner ? m_selectedBlockCorner.GetRow()
-                                                     : m_currentCellCoords.GetRow();
-                    if ( event.ControlDown() )
+                    // Also find the last or first visible column in any case.
+                    int col;
+                    if ( goToBeginning )
                     {
-                        row = m_numRows - 1;
-
-                        // Find visible row.
-                        for ( ; row >= 0; --row )
+                        for ( col = 0; col < m_numCols; ++col )
                         {
-                            if ( IsRowShown(row) )
+                            if ( IsColShown(GetColAt(col)) )
                                 break;
                         }
                     }
-
-                    int col = m_numCols - 1;
-                    // Find visible column.
-                    for ( ; col >= 0; --col )
+                    else
                     {
-                        if ( IsColShown(GetColAt(col)) )
-                            break;
+                        for ( col = m_numCols - 1; col >= 0; --col )
+                        {
+                            if ( IsColShown(GetColAt(col)) )
+                                break;
+                        }
                     }
 
                     if ( event.ShiftDown() )

From 610489360e3fde410c3c6009ca0ef40f56876843 Mon Sep 17 00:00:00 2001
From: Paul Licameli <paul.licameli@audacityteam.org>
Date: Wed, 10 Jun 2020 08:28:08 -0400
Subject: [PATCH 20/25] wxEventFilter's virtual dtor is non-inline to fix
 duplicate symbols

---
 include/wx/eventfilter.h | 7 ++-----
 src/common/appbase.cpp   | 5 +++++
 2 files changed, 7 insertions(+), 5 deletions(-)

diff --git include/wx/eventfilter.h include/wx/eventfilter.h
index 30eac4d3634..2a8b2f56670 100644
--- include/wx/eventfilter.h
+++ include/wx/eventfilter.h
@@ -19,7 +19,7 @@ class WXDLLIMPEXP_FWD_BASE wxEvtHandler;
 // wxEventFilter is used with wxEvtHandler::AddFilter() and ProcessEvent().
 // ----------------------------------------------------------------------------
 
-class wxEventFilter
+class WXDLLIMPEXP_BASE wxEventFilter
 {
 public:
     // Possible return values for FilterEvent().
@@ -43,10 +43,7 @@ class wxEventFilter
         m_next = NULL;
     }
 
-    virtual ~wxEventFilter()
-    {
-        wxASSERT_MSG( !m_next, "Forgot to call wxEvtHandler::RemoveFilter()?" );
-    }
+    virtual ~wxEventFilter();
 
     // This method allows to filter all the events processed by the program, so
     // you should try to return quickly from it to avoid slowing down the
diff --git src/common/appbase.cpp src/common/appbase.cpp
index 186d845ad5c..2f818e70979 100644
--- src/common/appbase.cpp
+++ src/common/appbase.cpp
@@ -1394,3 +1394,8 @@ void ShowAssertDialog(const wxString& file,
 }
 
 #endif // wxDEBUG_LEVEL
+
+wxEventFilter::~wxEventFilter()
+{
+  wxASSERT_MSG( !m_next, "Forgot to call wxEvtHandler::RemoveFilter()?" );
+}

From 027494baf6115a2460e5893cc9dc4d357c1a3bae Mon Sep 17 00:00:00 2001
From: Leland Lucius <github@homerow.net>
Date: Sun, 5 Jul 2020 13:28:44 -0500
Subject: [PATCH 21/25] Add an Audacity identifier to the version string

---
 include/wx/version.h | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git include/wx/version.h include/wx/version.h
index cdb72af1950..c1323967587 100644
--- include/wx/version.h
+++ include/wx/version.h
@@ -29,7 +29,7 @@
 #define wxMINOR_VERSION      1
 #define wxRELEASE_NUMBER     3
 #define wxSUBRELEASE_NUMBER  0
-#define wxVERSION_STRING   wxT("wxWidgets 3.1.3")
+#define wxVERSION_STRING   wxT("wxWidgets 3.1.3 (Audacity)")
 
 /*  nothing to update below this line when updating the version */
 /*  ---------------------------------------------------------------------------- */
@@ -48,12 +48,12 @@
 #define wxMAKE_VERSION_STRING(x, y, z) \
     wxSTRINGIZE(x) wxSTRINGIZE(y) wxSTRINGIZE(z)
 #define wxMAKE_VERSION_DOT_STRING(x, y, z) \
-    wxSTRINGIZE(x) "." wxSTRINGIZE(y) "." wxSTRINGIZE(z)
+    wxSTRINGIZE(x) "." wxSTRINGIZE(y) "." wxSTRINGIZE(z) " (Audacity)"
 
 #define wxMAKE_VERSION_STRING_T(x, y, z) \
     wxSTRINGIZE_T(x) wxSTRINGIZE_T(y) wxSTRINGIZE_T(z)
 #define wxMAKE_VERSION_DOT_STRING_T(x, y, z) \
-    wxSTRINGIZE_T(x) wxT(".") wxSTRINGIZE_T(y) wxT(".") wxSTRINGIZE_T(z)
+    wxSTRINGIZE_T(x) wxT(".") wxSTRINGIZE_T(y) wxT(".") wxSTRINGIZE_T(z) wxT(" (Audacity)")
 
 /*  these are used by src/msw/version.rc and should always be ASCII, not Unicode */
 #define wxVERSION_NUM_STRING \

From 8284f68298344dd76db86e4dbac4376b642afdfe Mon Sep 17 00:00:00 2001
From: Leland Lucius <github@homerow.net>
Date: Fri, 24 Jul 2020 10:53:29 -0500
Subject: [PATCH 22/25] Remove patch to msw/setup0.h

This will restore default wxDEBUG_LEVEL handling on Windows.
---
 include/wx/msw/setup0.h | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git include/wx/msw/setup0.h include/wx/msw/setup0.h
index e0e972b6148..edbfc9b5196 100644
--- include/wx/msw/setup0.h
+++ include/wx/msw/setup0.h
@@ -87,12 +87,11 @@
 // NDEBUG) or, on the contrary, enable more asserts, including the usually
 // disabled ones, in the debug build (then do it inside #ifndef NDEBUG)
 //
-// Uncommented for Audacity, and set to 1 (rather than 2) for debug builds.
-#ifdef NDEBUG
-  #define wxDEBUG_LEVEL 0
-#else
-  #define wxDEBUG_LEVEL 1
-#endif
+// #ifdef NDEBUG
+//  #define wxDEBUG_LEVEL 0
+// #else
+//  #define wxDEBUG_LEVEL 2
+// #endif
 
 // wxHandleFatalExceptions() may be used to catch the program faults at run
 // time and, instead of terminating the program with a usual GPF message box,

From 84e3f51eff521931b1f25db30d52b99af20f6f88 Mon Sep 17 00:00:00 2001
From: Leland Lucius <github@homerow.net>
Date: Fri, 24 Jul 2020 16:51:29 -0500
Subject: [PATCH 23/25] Revert "Remove patch to msw/setup0.h"

This reverts commit 8284f68298344dd76db86e4dbac4376b642afdfe.
---
 include/wx/msw/setup0.h | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git include/wx/msw/setup0.h include/wx/msw/setup0.h
index edbfc9b5196..e0e972b6148 100644
--- include/wx/msw/setup0.h
+++ include/wx/msw/setup0.h
@@ -87,11 +87,12 @@
 // NDEBUG) or, on the contrary, enable more asserts, including the usually
 // disabled ones, in the debug build (then do it inside #ifndef NDEBUG)
 //
-// #ifdef NDEBUG
-//  #define wxDEBUG_LEVEL 0
-// #else
-//  #define wxDEBUG_LEVEL 2
-// #endif
+// Uncommented for Audacity, and set to 1 (rather than 2) for debug builds.
+#ifdef NDEBUG
+  #define wxDEBUG_LEVEL 0
+#else
+  #define wxDEBUG_LEVEL 1
+#endif
 
 // wxHandleFatalExceptions() may be used to catch the program faults at run
 // time and, instead of terminating the program with a usual GPF message box,

From 58ad95e7981c9a2b116f318539c37889281baabe Mon Sep 17 00:00:00 2001
From: Paul Kulchenko <paul@kulchenko.com>
Date: Thu, 31 Oct 2019 02:59:14 -0700
Subject: [PATCH 24/25] Fix copy to clipboard by flushing the updated data.
 (#1623)

---
 src/osx/carbon/clipbrd.cpp | 8 +++++++-
 1 file changed, 7 insertions(+), 1 deletion(-)

diff --git include/wx/osx/font.h include/wx/osx/font.h
index 3d6591cda31..923cdb47f52 100644
--- include/wx/osx/font.h
+++ include/wx/osx/font.h
@@ -26,7 +26,8 @@ enum wxOSXSystemFont
     wxOSX_SYSTEM_FONT_MINI,
     wxOSX_SYSTEM_FONT_MINI_BOLD,
     wxOSX_SYSTEM_FONT_LABELS,
-    wxOSX_SYSTEM_FONT_VIEWS
+    wxOSX_SYSTEM_FONT_VIEWS,
+    wxOSX_SYSTEM_FONT_FIXED
 };
 
 
diff --git src/osx/carbon/font.cpp src/osx/carbon/font.cpp
index 95e9f93f9b0..a4cf4e5b232 100644
--- src/osx/carbon/font.cpp
+++ src/osx/carbon/font.cpp
@@ -471,6 +471,8 @@ wxFont::wxFont(wxOSXSystemFont font)
         case wxOSX_SYSTEM_FONT_VIEWS:
             uifont = kCTFontViewsFontType;
             break;
+        case wxOSX_SYSTEM_FONT_FIXED:
+            uifont = kCTFontUIFontUserFixedPitch;
         default:
             break;
     }
diff --git src/osx/cocoa/settings.mm src/osx/cocoa/settings.mm
index faa1336cc51..39afbfd74a5 100644
--- src/osx/cocoa/settings.mm
+++ src/osx/cocoa/settings.mm
@@ -196,7 +196,7 @@ static int wxOSXGetUserDefault(NSString* key, int defaultValue)
         case wxSYS_DEVICE_DEFAULT_FONT :
         case wxSYS_DEFAULT_GUI_FONT :
             {
-                return *wxSMALL_FONT ;
+                return wxFont(wxOSX_SYSTEM_FONT_SMALL) ;
             } ;
             break ;
         case wxSYS_OEM_FIXED_FONT :
@@ -204,7 +204,7 @@ static int wxOSXGetUserDefault(NSString* key, int defaultValue)
         case wxSYS_SYSTEM_FIXED_FONT :
         default :
             {
-                return *wxNORMAL_FONT ;
+                return wxFont(wxOSX_SYSTEM_FONT_FIXED) ;
             } ;
             break ;
 
