diff --git build/cmake/options.cmake build/cmake/options.cmake
index b7703811ac..a8c922c740 100644
--- build/cmake/options.cmake
+++ build/cmake/options.cmake
@@ -411,6 +411,9 @@ if(WIN32)
     wx_option(wxUSE_WINRT "enable WinRT support" ${wxUSE_WINRT_DEFAULT})
     wx_option(wxUSE_ACCESSIBILITY "enable accessibility support")
 endif()
+if(APPLE)
+    wx_option(wxUSE_ACCESSIBILITY "enable accessibility support" ON)
+endif()
 
 # this one is not really MSW-specific but it exists mainly to be turned off
 # under MSW, it should be off by default on the other platforms
diff --git build/cmake/setup.cmake build/cmake/setup.cmake
index a102731af9..d1bb2e1932 100644
--- build/cmake/setup.cmake
+++ build/cmake/setup.cmake
@@ -672,6 +672,10 @@ check_type_size(ssize_t SSIZE_T)
 
 test_big_endian(WORDS_BIGENDIAN)
 
+if(APPLE)
+    # for audacity
+    set(wxUSE_ACCESSIBILITY ON)
+endif()
 configure_file(build/cmake/setup.h.in ${wxSETUP_HEADER_FILE})
 if(DEFINED wxSETUP_HEADER_FILE_DEBUG)
     # The debug version may be configured with different values in the future
diff --git include/wx/access.h include/wx/access.h
index 4948969209..ead3363859 100644
--- include/wx/access.h
+++ include/wx/access.h
@@ -371,6 +371,20 @@ private:
     #include "wx/msw/ole/access.h"
 #endif
 
+#if defined(__WXMAC__)
+
+class WXDLLIMPEXP_CORE wxAccessible : public wxAccessibleBase
+{
+public:
+   wxAccessible(wxWindow *win = NULL) : wxAccessibleBase(win) {}
+   virtual ~wxAccessible() {}
+
+   static void NotifyEvent
+   (int eventType, wxWindow* window, wxAccObject objectType, int objectId);
+};
+
+#endif
+
 #endif // wxUSE_ACCESSIBILITY
 
 #endif // _WX_ACCESSBASE_H_
diff --git include/wx/button.h include/wx/button.h
index f31166413e..3e89721cf2 100644
--- include/wx/button.h
+++ include/wx/button.h
@@ -42,6 +42,10 @@ public:
     // returns the default button size for this platform
     static wxSize GetDefaultSize();
 
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const wxOVERRIDE { return true; }
+#endif
+
 protected:
     wxDECLARE_NO_COPY_CLASS(wxButtonBase);
 };
diff --git include/wx/chkconf.h include/wx/chkconf.h
index 82bb132b8a..8811e8c299 100644
--- include/wx/chkconf.h
+++ include/wx/chkconf.h
@@ -1511,9 +1511,9 @@
  */
 #if wxUSE_GUI
 
-#if wxUSE_ACCESSIBILITY && !defined(__WXMSW__)
+#if wxUSE_ACCESSIBILITY && !( defined(__WXMSW__) || defined(__WXOSX_COCOA__) || defined(__APPLE__))
 #   ifdef wxABORT_ON_CONFIG_ERROR
-#       error "wxUSE_ACCESSIBILITY is currently only supported under wxMSW"
+#       error "wxUSE_ACCESSIBILITY is currently only supported under wxMSW or Cocoa"
 #   else
 #       undef wxUSE_ACCESSIBILITY
 #       define wxUSE_ACCESSIBILITY 0
diff --git include/wx/choice.h include/wx/choice.h
index b5bfac3b1a..8e014a6677 100644
--- include/wx/choice.h
+++ include/wx/choice.h
@@ -57,6 +57,10 @@ public:
     // override wxItemContainer::IsSorted
     virtual bool IsSorted() const wxOVERRIDE { return HasFlag(wxCB_SORT); }
 
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const wxOVERRIDE { return true; }
+#endif
+
 protected:
     // The generic implementation doesn't determine the height correctly and
     // doesn't account for the width of the arrow but does take into account
diff --git include/wx/datetimectrl.h include/wx/datetimectrl.h
index 30f23dfffe..441cf945bf 100644
--- include/wx/datetimectrl.h
+++ include/wx/datetimectrl.h
@@ -32,6 +32,9 @@ public:
     // Set/get the date or time (in the latter case, time part is ignored).
     virtual void SetValue(const wxDateTime& dt) = 0;
     virtual wxDateTime GetValue() const = 0;
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const wxOVERRIDE { return true; }
+#endif
 };
 
 #if defined(__WXMSW__) && !defined(__WXUNIVERSAL__)
diff --git include/wx/eventfilter.h include/wx/eventfilter.h
index 30eac4d363..2a8b2f5667 100644
--- include/wx/eventfilter.h
+++ include/wx/eventfilter.h
@@ -19,7 +19,7 @@ class WXDLLIMPEXP_FWD_BASE wxEvtHandler;
 // wxEventFilter is used with wxEvtHandler::AddFilter() and ProcessEvent().
 // ----------------------------------------------------------------------------
 
-class wxEventFilter
+class WXDLLIMPEXP_BASE wxEventFilter
 {
 public:
     // Possible return values for FilterEvent().
@@ -43,10 +43,7 @@ public:
         m_next = NULL;
     }
 
-    virtual ~wxEventFilter()
-    {
-        wxASSERT_MSG( !m_next, "Forgot to call wxEvtHandler::RemoveFilter()?" );
-    }
+    virtual ~wxEventFilter();
 
     // This method allows to filter all the events processed by the program, so
     // you should try to return quickly from it to avoid slowing down the
diff --git include/wx/generic/grid.h include/wx/generic/grid.h
index 2e1fcb89a6..27382d872f 100644
--- include/wx/generic/grid.h
+++ include/wx/generic/grid.h
@@ -2173,13 +2173,13 @@ protected:
 
     // this function is called to extend the block being currently selected
     // from mouse and keyboard event handlers
-    void UpdateBlockBeingSelected(int topRow, int leftCol,
-                                  int bottomRow, int rightCol);
+    void UpdateBlockBeingSelected(int blockStartRow, int blockStartCol,
+                                  int blockEndRow, int blockEndCol);
 
-    void UpdateBlockBeingSelected(const wxGridCellCoords& topLeft,
-                        const wxGridCellCoords& bottomRight)
-        { UpdateBlockBeingSelected(topLeft.GetRow(), topLeft.GetCol(),
-                         bottomRight.GetRow(), bottomRight.GetCol()); }
+    void UpdateBlockBeingSelected(const wxGridCellCoords& blockStart,
+                                  const wxGridCellCoords& blockEnd)
+        { UpdateBlockBeingSelected(blockStart.GetRow(), blockStart.GetCol(),
+                                   blockEnd.GetRow(), blockEnd.GetCol()); }
 
     friend class WXDLLIMPEXP_FWD_CORE wxGridSelection;
     friend class wxGridRowOperations;
diff --git include/wx/listbox.h include/wx/listbox.h
index 69525e219f..6e1c53b5d1 100644
--- include/wx/listbox.h
+++ include/wx/listbox.h
@@ -96,7 +96,9 @@ public:
     // return the index of the item at this position or wxNOT_FOUND
     int HitTest(const wxPoint& point) const { return DoListHitTest(point); }
     int HitTest(int x, int y) const { return DoListHitTest(wxPoint(x, y)); }
-
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const wxOVERRIDE { return true; }
+#endif
 
 protected:
     virtual void DoSetFirstItem(int n) = 0;
diff --git include/wx/msw/setup0.h include/wx/msw/setup0.h
index 7b502ecbef..1cc27ceb20 100644
--- include/wx/msw/setup0.h
+++ include/wx/msw/setup0.h
@@ -87,11 +87,12 @@
 // NDEBUG) or, on the contrary, enable more asserts, including the usually
 // disabled ones, in the debug build (then do it inside #ifndef NDEBUG)
 //
-// #ifdef NDEBUG
-//  #define wxDEBUG_LEVEL 0
-// #else
-//  #define wxDEBUG_LEVEL 2
-// #endif
+// Uncommented for Audacity, and set to 1 (rather than 2) for debug builds.
+#ifdef NDEBUG
+  #define wxDEBUG_LEVEL 0
+#else
+  #define wxDEBUG_LEVEL 1
+#endif
 
 // wxHandleFatalExceptions() may be used to catch the program faults at run
 // time and, instead of terminating the program with a usual GPF message box,
@@ -1419,14 +1420,8 @@
 // Use wxAccessible for enhanced and customisable accessibility.
 // Depends on wxUSE_OLE on MSW.
 //
-// Default is 1 on MSW, 0 elsewhere.
-//
-// Recommended setting (at present): 1 (MSW-only)
-#ifdef __WXMSW__
+// Set to 1 for Audacity
 #define wxUSE_ACCESSIBILITY 1
-#else
-#define wxUSE_ACCESSIBILITY 0
-#endif
 
 // ----------------------------------------------------------------------------
 // miscellaneous settings
diff --git include/wx/osx/dvrenderers.h include/wx/osx/dvrenderers.h
index 1b8231eebf..37a193eea2 100644
--- include/wx/osx/dvrenderers.h
+++ include/wx/osx/dvrenderers.h
@@ -87,6 +87,9 @@ public:
     virtual void OSXOnCellChanged(NSObject *value,
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
+#if wxUSE_ACCESSIBILITY
+      virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
 
 private:
 #if wxUSE_MARKUP && wxOSX_USE_COCOA
@@ -112,6 +115,10 @@ public:
 
     virtual bool MacRender() wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewBitmapRenderer);
 };
@@ -137,6 +144,10 @@ public:
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     wxArrayString m_choices;
 
@@ -160,6 +171,10 @@ public:
     virtual void OSXOnCellChanged(NSObject *value,
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
+
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
 };
 
 // ---------------------------------------------------------
@@ -180,6 +195,10 @@ public:
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewIconTextRenderer);
 };
@@ -206,6 +225,10 @@ public:
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     void DoInitButtonCell(int buttonType);
 
@@ -231,7 +254,9 @@ public:
     virtual void OSXOnCellChanged(NSObject *value,
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
-
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
 private:
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewProgressRenderer);
 };
@@ -255,6 +280,10 @@ public:
                                   const wxDataViewItem& item,
                                   unsigned col) wxOVERRIDE;
 
+#if wxUSE_ACCESSIBILITY
+   virtual wxString GetAccessibleDescription() const wxOVERRIDE { return {}; }
+#endif // wxUSE_ACCESSIBILITY
+
 private:
     wxDECLARE_DYNAMIC_CLASS_NO_COPY(wxDataViewDateRenderer);
 };
diff --git include/wx/osx/font.h include/wx/osx/font.h
index 3d6591cda3..923cdb47f5 100644
--- include/wx/osx/font.h
+++ include/wx/osx/font.h
@@ -26,7 +26,8 @@ enum wxOSXSystemFont
     wxOSX_SYSTEM_FONT_MINI,
     wxOSX_SYSTEM_FONT_MINI_BOLD,
     wxOSX_SYSTEM_FONT_LABELS,
-    wxOSX_SYSTEM_FONT_VIEWS
+    wxOSX_SYSTEM_FONT_VIEWS,
+    wxOSX_SYSTEM_FONT_FIXED
 };
 
 
diff --git include/wx/version.h include/wx/version.h
index cdb72af195..c132396758 100644
--- include/wx/version.h
+++ include/wx/version.h
@@ -29,7 +29,7 @@
 #define wxMINOR_VERSION      1
 #define wxRELEASE_NUMBER     3
 #define wxSUBRELEASE_NUMBER  0
-#define wxVERSION_STRING   wxT("wxWidgets 3.1.3")
+#define wxVERSION_STRING   wxT("wxWidgets 3.1.3 (Audacity)")
 
 /*  nothing to update below this line when updating the version */
 /*  ---------------------------------------------------------------------------- */
@@ -48,12 +48,12 @@
 #define wxMAKE_VERSION_STRING(x, y, z) \
     wxSTRINGIZE(x) wxSTRINGIZE(y) wxSTRINGIZE(z)
 #define wxMAKE_VERSION_DOT_STRING(x, y, z) \
-    wxSTRINGIZE(x) "." wxSTRINGIZE(y) "." wxSTRINGIZE(z)
+    wxSTRINGIZE(x) "." wxSTRINGIZE(y) "." wxSTRINGIZE(z) " (Audacity)"
 
 #define wxMAKE_VERSION_STRING_T(x, y, z) \
     wxSTRINGIZE_T(x) wxSTRINGIZE_T(y) wxSTRINGIZE_T(z)
 #define wxMAKE_VERSION_DOT_STRING_T(x, y, z) \
-    wxSTRINGIZE_T(x) wxT(".") wxSTRINGIZE_T(y) wxT(".") wxSTRINGIZE_T(z)
+    wxSTRINGIZE_T(x) wxT(".") wxSTRINGIZE_T(y) wxT(".") wxSTRINGIZE_T(z) wxT(" (Audacity)")
 
 /*  these are used by src/msw/version.rc and should always be ASCII, not Unicode */
 #define wxVERSION_NUM_STRING \
diff --git include/wx/window.h include/wx/window.h
index 5dbecc519a..dc58d6cbd7 100644
--- include/wx/window.h
+++ include/wx/window.h
@@ -252,7 +252,9 @@ public:
 
     // moving/resizing
     // ---------------
-
+#ifdef __WXMAC__
+    virtual bool NeedsFocusRing() const { return false; }
+#endif
         // set the window size and/or position
     void SetSize( int x, int y, int width, int height,
                   int sizeFlags = wxSIZE_AUTO )
diff --git setup.h.in setup.h.in
index b33699b9c9..a64244ec6e 100644
--- setup.h.in
+++ setup.h.in
@@ -557,8 +557,8 @@
 
 #define wxUSE_DRAG_AND_DROP 0
 
-#ifdef __WXMSW__
-#define wxUSE_ACCESSIBILITY 0
+#if (defined (__WXMSW__) || defined(__WXOSX_COCOA__))
+#define wxUSE_ACCESSIBILITY 1
 #else
 #define wxUSE_ACCESSIBILITY 0
 #endif
diff --git src/common/appbase.cpp src/common/appbase.cpp
index 186d845ad5..2f818e7097 100644
--- src/common/appbase.cpp
+++ src/common/appbase.cpp
@@ -1394,3 +1394,8 @@ void ShowAssertDialog(const wxString& file,
 }
 
 #endif // wxDEBUG_LEVEL
+
+wxEventFilter::~wxEventFilter()
+{
+  wxASSERT_MSG( !m_next, "Forgot to call wxEvtHandler::RemoveFilter()?" );
+}
diff --git src/common/filefn.cpp src/common/filefn.cpp
index d2b88ca7c6..f9b5c093e6 100644
--- src/common/filefn.cpp
+++ src/common/filefn.cpp
@@ -1115,7 +1115,8 @@ wxCopyFile (const wxString& file1, const wxString& file2, bool overwrite)
 bool
 wxRenameFile(const wxString& file1, const wxString& file2, bool overwrite)
 {
-    if ( !overwrite && wxFileExists(file2) )
+    bool exists = wxFileExists(file2);
+    if ( !overwrite && exists )
     {
         wxLogSysError
         (
@@ -1126,9 +1127,28 @@ wxRenameFile(const wxString& file1, const wxString& file2, bool overwrite)
         return false;
     }
 
-    // Normal system call
+// This Audacity specific fixup should only be for Windows.
+#if !defined( __WINDOWS__ )
   if ( wxRename (file1, file2) == 0 )
     return true;
+#else 
+    // Normal system call
+    //
+    // For explanation, see:  (warning...based mostly on observed behavior)
+    //   http://bugzilla.audacityteam.org/show_bug.cgi?id=1266
+    //   https://github.com/audacity/audacity/pull/94
+  unsigned long doserrno = 0;
+  for (int i = 0; i < 2000; i++)
+  {
+    if ( wxRename (file1, file2) == 0 )
+      return true;
+    unsigned long doserrno;
+    _get_doserrno(&doserrno);
+    if (doserrno != ERROR_ACCESS_DENIED && (doserrno != ERROR_ALREADY_EXISTS || exists))
+        break;
+    wxMilliSleep(1);
+  }
+#endif
 
   // Try to copy
   if (wxCopyFile(file1, file2, overwrite)) {
diff --git src/generic/grid.cpp src/generic/grid.cpp
index 6f6fb05e2d..079b0aaea9 100644
--- src/generic/grid.cpp
+++ src/generic/grid.cpp
@@ -5015,15 +5015,80 @@ void wxGrid::OnKeyDown( wxKeyEvent& event )
                 break;
 
             case WXK_HOME:
-                GoToCell(event.ControlDown() ? 0
-                                             : m_currentCellCoords.GetRow(),
-                         0);
-                break;
-
             case WXK_END:
-                GoToCell(event.ControlDown() ? m_numRows - 1
-                                             : m_currentCellCoords.GetRow(),
-                         m_numCols - 1);
+                if ( m_currentCellCoords != wxGridNoCellCoords )
+                {
+                    const bool goToBeginning = event.GetKeyCode() == WXK_HOME;
+
+                    // Find the first or last visible row if we need to go to it
+                    // (without Control, we keep the current row).
+                    int row;
+                    if ( event.ControlDown() )
+                    {
+                        if ( goToBeginning )
+                        {
+                            for ( row = 0; row < m_numRows; ++row )
+                            {
+                                if ( IsRowShown(row) )
+                                    break;
+                            }
+                        }
+                        else
+                        {
+                            for ( row = m_numRows - 1; row >= 0; --row )
+                            {
+                                if ( IsRowShown(row) )
+                                    break;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        // If we're selecting, continue in the same row, which
+                        // may well be different from the one in which we
+                        // started selecting.
+                        if ( event.ShiftDown() &&
+                                m_selectedBlockCorner != wxGridNoCellCoords )
+                        {
+                            row = m_selectedBlockCorner.GetRow();
+                        }
+                        else // Just use the current row.
+                        {
+                            row = m_currentCellCoords.GetRow();
+                        }
+                    }
+
+                    // Also find the last or first visible column in any case.
+                    int col;
+                    if ( goToBeginning )
+                    {
+                        for ( col = 0; col < m_numCols; ++col )
+                        {
+                            if ( IsColShown(GetColAt(col)) )
+                                break;
+                        }
+                    }
+                    else
+                    {
+                        for ( col = m_numCols - 1; col >= 0; --col )
+                        {
+                            if ( IsColShown(GetColAt(col)) )
+                                break;
+                        }
+                    }
+
+                    if ( event.ShiftDown() )
+                    {
+                        UpdateBlockBeingSelected(m_currentCellCoords,
+                                                 wxGridCellCoords(row, col));
+                        MakeCellVisible(row, col);
+                    }
+                    else
+                    {
+                        ClearSelection();
+                        GoToCell(row, GetColAt(col));
+                    }
+                }
                 break;
 
             case WXK_PAGEUP:
@@ -5261,11 +5326,16 @@ bool wxGrid::SetCurrentCell( const wxGridCellCoords& coords )
 }
 
 void
-wxGrid::UpdateBlockBeingSelected(int topRow, int leftCol,
-                                 int bottomRow, int rightCol)
+wxGrid::UpdateBlockBeingSelected(int blockStartRow, int blockStartCol,
+                                 int blockEndRow, int blockEndCol)
 {
+    m_selectedBlockCorner = wxGridCellCoords(blockEndRow, blockEndCol);
     MakeCellVisible(m_selectedBlockCorner);
-    m_selectedBlockCorner = wxGridCellCoords(bottomRow, rightCol);
+
+    int topRow = wxMin(blockStartRow, blockEndRow);
+    int leftCol = wxMin(blockStartCol, blockEndCol);
+    int bottomRow = wxMax(blockStartRow, blockEndRow);
+    int rightCol = wxMax(blockStartCol, blockEndCol);
 
     if ( m_selection )
     {
@@ -5303,9 +5373,6 @@ wxGrid::UpdateBlockBeingSelected(int topRow, int leftCol,
         }
     }
 
-    EnsureFirstLessThanSecond(topRow, bottomRow);
-    EnsureFirstLessThanSecond(leftCol, rightCol);
-
     wxGridCellCoords updateTopLeft = wxGridCellCoords(topRow, leftCol),
                      updateBottomRight = wxGridCellCoords(bottomRow, rightCol);
 
diff --git src/gtk/dataview.cpp src/gtk/dataview.cpp
index f4e14017b1..d3eb549a6a 100644
--- src/gtk/dataview.cpp
+++ src/gtk/dataview.cpp
@@ -2604,6 +2604,7 @@ public:
         m_window = window;
 
         m_context = window->GTKGetPangoDefaultContext();
+        g_object_ref(m_context);
         m_layout = pango_layout_new( m_context );
         m_fontdesc = pango_font_description_copy(gtk_widget_get_style(widget)->font_desc);
 
diff --git src/gtk/dcclient.cpp src/gtk/dcclient.cpp
index feea364099..015b3ee766 100644
--- src/gtk/dcclient.cpp
+++ src/gtk/dcclient.cpp
@@ -304,6 +304,7 @@ wxWindowDCImpl::wxWindowDCImpl( wxDC *owner, wxWindow *window ) :
     }
 
     m_context = window->GTKGetPangoDefaultContext();
+    g_object_ref(m_context);
     m_layout = pango_layout_new( m_context );
     m_fontdesc = pango_font_description_copy( widget->style->font_desc );
 
@@ -313,6 +314,8 @@ wxWindowDCImpl::wxWindowDCImpl( wxDC *owner, wxWindow *window ) :
          // Don't report problems as per MSW.
          m_ok = true;
 
+         m_window = window;
+
          return;
     }
 
@@ -344,6 +347,8 @@ wxWindowDCImpl::~wxWindowDCImpl()
 {
     Destroy();
 
+    if (m_context)
+        g_object_unref(m_context);
     if (m_layout)
         g_object_unref (m_layout);
     if (m_fontdesc)
@@ -1536,6 +1541,10 @@ void wxWindowDCImpl::SetFont( const wxFont &font )
             // at least, and it doesn't hurt to do it.
             if (oldContext != m_context)
             {
+                g_object_ref(m_context);
+                if (oldContext)
+                    g_object_unref(oldContext);
+
                 if (m_layout)
                     g_object_unref (m_layout);
 
diff --git src/gtk/dcmemory.cpp src/gtk/dcmemory.cpp
index 9ac137d837..f2e20da024 100644
--- src/gtk/dcmemory.cpp
+++ src/gtk/dcmemory.cpp
@@ -40,7 +40,6 @@ wxMemoryDCImpl::wxMemoryDCImpl( wxMemoryDC *owner, wxDC *WXUNUSED(dc) )
 
 wxMemoryDCImpl::~wxMemoryDCImpl()
 {
-    g_object_unref(m_context);
 }
 
 void wxMemoryDCImpl::Init()
diff --git src/gtk/dcscreen.cpp src/gtk/dcscreen.cpp
index ea9f607ed9..1041e4fcca 100644
--- src/gtk/dcscreen.cpp
+++ src/gtk/dcscreen.cpp
@@ -50,8 +50,6 @@ void wxScreenDCImpl::Init()
 
 wxScreenDCImpl::~wxScreenDCImpl()
 {
-    g_object_unref(m_context);
-
     gdk_gc_set_subwindow( m_penGC, GDK_CLIP_BY_CHILDREN );
     gdk_gc_set_subwindow( m_brushGC, GDK_CLIP_BY_CHILDREN );
     gdk_gc_set_subwindow( m_textGC, GDK_CLIP_BY_CHILDREN );
diff --git src/gtk/toplevel.cpp src/gtk/toplevel.cpp
index 57a457a418..27828c98e6 100644
--- src/gtk/toplevel.cpp
+++ src/gtk/toplevel.cpp
@@ -1079,6 +1079,16 @@ bool wxTopLevelWindowGTK::Show( bool show )
 
     if (change && !show)
     {
+        // Generate wxEVT_KILL_FOCUS for the currently focused control
+        // immediately (i.e. without waiting until the window is destroyed and
+        // doing it from its dtor), as it could be too late to execute the
+        // handler for this event, or other events triggered by receiving it,
+        // by then because the wxTLW will have been half-destroyed by then.
+        if (GTK_IS_WINDOW(m_widget))
+        {
+            gtk_window_set_focus( GTK_WINDOW(m_widget), NULL );
+        }
+
         // make sure window has a non-default position, so when it is shown
         // again, it won't be repositioned by WM as if it were a new window
         // Note that this must be done _after_ the window is hidden.
diff --git src/gtk/window.cpp src/gtk/window.cpp
index 2ff5c94b07..56bc3572d7 100644
--- src/gtk/window.cpp
+++ src/gtk/window.cpp
@@ -1681,7 +1681,7 @@ gtk_window_button_press_callback( GtkWidget* WXUNUSED_IN_GTK3(widget),
         return TRUE;
 
     if ((event_type == wxEVT_LEFT_DOWN) && !win->IsOfStandardClass() &&
-        (gs_currentFocus != win) /* && win->IsFocusable() */)
+        (gs_currentFocus != win) && win->IsFocusable())
     {
         win->SetFocus();
     }
diff --git src/osx/carbon/font.cpp src/osx/carbon/font.cpp
index 54ed729d9f..c266179476 100644
--- src/osx/carbon/font.cpp
+++ src/osx/carbon/font.cpp
@@ -469,6 +469,8 @@ wxFont::wxFont(wxOSXSystemFont font)
         case wxOSX_SYSTEM_FONT_VIEWS:
             uifont = kCTFontViewsFontType;
             break;
+        case wxOSX_SYSTEM_FONT_FIXED:
+            uifont = kCTFontUIFontUserFixedPitch;
         default:
             break;
     }
diff --git src/osx/cocoa/settings.mm src/osx/cocoa/settings.mm
index fc39244e18..7c534b0031 100644
--- src/osx/cocoa/settings.mm
+++ src/osx/cocoa/settings.mm
@@ -196,7 +196,7 @@ wxFont wxSystemSettingsNative::GetFont(wxSystemFont index)
         case wxSYS_DEVICE_DEFAULT_FONT :
         case wxSYS_DEFAULT_GUI_FONT :
             {
-                return *wxSMALL_FONT ;
+                return wxFont(wxOSX_SYSTEM_FONT_SMALL) ;
             } ;
             break ;
         case wxSYS_OEM_FIXED_FONT :
@@ -204,7 +204,7 @@ wxFont wxSystemSettingsNative::GetFont(wxSystemFont index)
         case wxSYS_SYSTEM_FIXED_FONT :
         default :
             {
-                return *wxNORMAL_FONT ;
+                return wxFont(wxOSX_SYSTEM_FONT_FIXED) ;
             } ;
             break ;
 
diff --git src/osx/cocoa/window.mm src/osx/cocoa/window.mm
index 6f570d531e..e0a0206fb4 100644
--- src/osx/cocoa/window.mm
+++ src/osx/cocoa/window.mm
@@ -17,7 +17,9 @@
     #include "wx/textctrl.h"
     #include "wx/combobox.h"
     #include "wx/radiobut.h"
+    #include "wx/button.h"
 #endif
+#include "wx/hashset.h"
 
 #ifdef __WXMAC__
     #include "wx/osx/private.h"
@@ -39,6 +41,7 @@
 #endif
 
 #include <objc/objc-runtime.h>
+#include "wx/string.h"
 
 // Get the window with the focus
 
@@ -95,12 +98,12 @@ WXWidget wxWidgetImpl::FindFocus()
 wxWidgetImpl* wxWidgetImpl::FindBestFromWXWidget(WXWidget control)
 {
     wxWidgetImpl* impl = FindFromWXWidget(control);
-    
+
     // NSScrollViews can have their subviews like NSClipView
     // therefore check and use the NSScrollView peer in that case
     if ( impl == NULL && [[control superview] isKindOfClass:[NSScrollView class]])
         impl = FindFromWXWidget([control superview]);
-    
+
     return impl;
 }
 
@@ -118,11 +121,11 @@ NSRect wxOSXGetFrameForControl( wxWindowMac* window , const wxPoint& pos , const
 
 @interface wxNSView : NSView
 {
-    BOOL _hasToolTip;    
+    BOOL _hasToolTip;
     NSTrackingRectTag   _lastToolTipTrackTag;
     id              _lastToolTipOwner;
     void*           _lastUserData;
-    
+
 }
 
 @end // wxNSView
@@ -213,7 +216,7 @@ NSRect wxOSXGetFrameForControl( wxWindowMac* window , const wxPoint& pos , const
         const UniCharCount maxStringLength = 255;
         UniCharCount actualStringLength = 0;
         UniChar unicodeString[maxStringLength];
-        
+
         OSStatus status = UCKeyTranslate(keyboardLayout,
                                          [self keyCode],
                                          kUCKeyActionDown,
@@ -224,7 +227,7 @@ NSRect wxOSXGetFrameForControl( wxWindowMac* window , const wxPoint& pos , const
                                          maxStringLength,
                                          &actualStringLength,
                                          unicodeString);
-        
+
         if(status == noErr)
             result = [NSString stringWithCharacters:unicodeString length:(NSInteger)actualStringLength];
     }
@@ -347,7 +350,7 @@ long wxOSXTranslateCocoaKey( NSEvent* event, int eventType )
         default:
             break;
     }
-    
+
     // Check for NUMPAD keys.  For KEY_UP/DOWN events we need to use the
     // WXK_NUMPAD constants, but for the CHAR event we want to use the
     // standard ascii values
@@ -516,7 +519,7 @@ void wxWidgetCocoaImpl::SetupKeyEvent(wxKeyEvent &wxevent , NSEvent * nsEvent, N
 UInt32 g_lastButton = 0 ;
 bool g_lastButtonWasFakeRight = false ;
 
-// better scroll wheel support 
+// better scroll wheel support
 // see http://lists.apple.com/archives/cocoa-dev/2007/Feb/msg00050.html
 
 @interface NSEvent (DeviceDelta)
@@ -534,20 +537,20 @@ wxSetupCoordinates(NSView* view, wxCoord &x, wxCoord &y, NSEvent* nsEvent)
 {
     NSRect locationInWindow = NSZeroRect;
     locationInWindow.origin = [nsEvent locationInWindow];
-    
+
     // adjust coordinates for the window of the target view
     if ( [nsEvent window] != [view window] )
     {
         if ( [nsEvent window] != nil )
             locationInWindow = [[nsEvent window] convertRectToScreen:locationInWindow];
-        
+
         if ( [view window] != nil )
             locationInWindow = [[view window] convertRectFromScreen:locationInWindow];
     }
-    
+
     NSPoint locationInView = [view convertPoint:locationInWindow.origin fromView:nil];
     wxPoint locationInViewWX = wxFromNSPoint( view, locationInView );
-        
+
     x = locationInViewWX.x;
     y = locationInViewWX.y;
 
@@ -562,7 +565,7 @@ void wxWidgetCocoaImpl::SetupMouseEvent( wxMouseEvent &wxevent , NSEvent * nsEve
 {
     int eventType = [nsEvent type];
     UInt32 modifiers = [nsEvent modifierFlags] ;
-    
+
     SetupCoordinates(wxevent.m_x, wxevent.m_y, nsEvent);
 
     // these parameters are not given for all events
@@ -718,7 +721,7 @@ void wxWidgetCocoaImpl::SetupMouseEvent( wxMouseEvent &wxevent , NSEvent * nsEve
                 deltaX = [nsEvent scrollingDeltaX] * 10;
                 deltaY = [nsEvent scrollingDeltaY] * 10;
             }
-            
+
             wxevent.m_wheelDelta = 10;
             wxevent.m_wheelInverted = [nsEvent isDirectionInvertedFromDevice];
             wxevent.m_linesPerAction = 1;
@@ -752,12 +755,12 @@ void wxWidgetCocoaImpl::SetupMouseEvent( wxMouseEvent &wxevent , NSEvent * nsEve
         case NSMouseMoved :
             wxevent.SetEventType( wxEVT_MOTION ) ;
             break;
-        
+
         case NSEventTypeMagnify:
             wxevent.SetEventType( wxEVT_MAGNIFY );
             wxevent.m_magnification = [nsEvent magnification];
             break;
-            
+
         default :
             break ;
     }
@@ -807,7 +810,7 @@ static void SetDrawingEnabledIfFrozenRecursive(wxWidgetCocoaImpl *impl, bool ena
     }
 }
 
-/* idea taken from webkit sources: overwrite the methods that (private) NSToolTipManager will use to attach its tracking rectangle 
+/* idea taken from webkit sources: overwrite the methods that (private) NSToolTipManager will use to attach its tracking rectangle
  * then when changing the tooltip send fake view-exit and view-enter methods which will lead to a tooltip refresh
  */
 
@@ -855,7 +858,7 @@ static void SetDrawingEnabledIfFrozenRecursive(wxWidgetCocoaImpl *impl, bool ena
         _hasToolTip = YES;
         [self _sendToolTipMouseEntered];
     }
-    else 
+    else
     {
         if ( _hasToolTip )
         {
@@ -880,7 +883,7 @@ static void SetDrawingEnabledIfFrozenRecursive(wxWidgetCocoaImpl *impl, bool ena
 
 - (void)removeTrackingRect:(NSTrackingRectTag)tag
 {
-    if (tag == _lastToolTipTrackTag) 
+    if (tag == _lastToolTipTrackTag)
     {
         _lastUserData = NULL;
         _lastToolTipOwner = nil;
@@ -964,7 +967,7 @@ void wxOSX_insertText(NSView* self, SEL _cmd, NSString* text);
 }
 
 - (NSRange)selectedRange
-{    
+{
     return NSMakeRange(NSNotFound, 0);
 }
 
@@ -1000,6 +1003,22 @@ void wxOSX_insertText(NSView* self, SEL _cmd, NSString* text);
 @end // wxNSView(TextInput)
 
 
+// An objective-C object that can be returned to Cocoa to receive the
+// callbacks for accessibility, in case its parent defines it as an accessible
+// sub-element that does not correspond to an entire wxWindow.
+@interface wxAccessibilityChild : NSObject
+{
+   wxAccessible *accessible;
+   NSInteger number;
+}
+
+- (id)initWithAccessible: (wxAccessible*)accessible_
+               andNumber: (NSInteger)number_;
+
++ (id)accessibilityChildWithAccessible: (wxAccessible*)accessible_
+                             andNumber: (NSInteger)number_;
+@end
+
 //
 // event handlers
 //
@@ -1045,8 +1064,1410 @@ BOOL wxOSX_performDragOperation( id self, SEL _cmd, id <NSDraggingInfo> sender )
     return impl->performDragOperation(sender, self, _cmd) ? YES:NO ;
 }
 
+namespace {
+   wxAccessible *findAccessible( id view )
+   {
+      wxWidgetCocoaImpl* impl;
+      wxWindow* win;
+      wxAccessible *accessible;
+
+      if ((impl =
+           (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( view )) &&
+          (win = impl->GetWXPeer()) &&
+          (accessible = win->GetAccessible()))
+         return accessible;
+
+      return NULL;
+   }
+
+   id GetUIElement
+   (wxAccessible &accessible, int childID = wxACC_SELF,
+    wxAccessible *pChild = NULL)
+   {
+      if (pChild)
+         return pChild->GetWindow()->GetPeer()->GetWXWidget();
+      else
+         return
+         [wxAccessibilityChild accessibilityChildWithAccessible: &accessible
+                                                      andNumber: childID];
+   }
+
+   struct wxNSAccessibilityAttribute
+   {
+      explicit
+      wxNSAccessibilityAttribute(NSString *name_, bool dummy = false);
+
+      struct Hash
+      {
+         size_t operator()( const void* k ) const
+         {
+            return
+               [static_cast<const wxNSAccessibilityAttribute*>(k)->name hash];
+         }
+      };
+
+      struct Equal
+      {
+         bool operator()( const void* a, const void* b ) const
+         {
+            return
+               [static_cast<const wxNSAccessibilityAttribute*>(a)->name
+                isEqual:
+                static_cast<const wxNSAccessibilityAttribute*>(b)->name];
+         }
+      };
+
+      void RaiseException(id element, id value = nil) const
+      {
+         NSAccessibilityRaiseBadArgumentException(element, name, value);
+      }
+
+      virtual bool IsPresent
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         return false;
+      }
+
+      virtual bool IsSettable
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         return false;
+      }
+
+      virtual id Get
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         RaiseException(element);
+         return nil;
+      }
+
+      virtual void Set
+         (id element, wxAccessible &accessible, int childID, id value) const
+      {
+         RaiseException(element, value);
+      }
+
+      NSString *const name;
+   };
+
+   WX_DECLARE_HASH_SET(
+      wxNSAccessibilityAttribute*,
+      wxNSAccessibilityAttribute::Hash,
+      wxNSAccessibilityAttribute::Equal,
+      AllAttributes
+   );
+
+   AllAttributes sAllAttributes;
+
+   wxNSAccessibilityAttribute::wxNSAccessibilityAttribute
+      (NSString *name_, bool dummy)
+   : name (name_)
+   {
+      if (!dummy)
+         sAllAttributes.insert(this);
+   }
+
+   const wxNSAccessibilityAttribute *findAttribute(id element, NSString *name)
+   {
+      wxNSAccessibilityAttribute attr(name, true);
+      AllAttributes::const_iterator it = sAllAttributes.find(&attr);
+      if (it != sAllAttributes.end())
+         return *it;
+      return NULL;
+   }
+
+   NSArray *findAttributeNames
+   ( id self, wxAccessible &accessible, int childId,
+    NSArray *otherAttributes )
+   {
+      NSMutableArray *result =
+      otherAttributes
+      ? [NSMutableArray arrayWithArray: otherAttributes]
+      : [NSMutableArray arrayWithCapacity: sAllAttributes.size()];
+      AllAttributes::const_iterator it = sAllAttributes.begin(),
+      end = sAllAttributes.end();
+      for (; it != end; ++it)
+      {
+         const wxNSAccessibilityAttribute &attribute = **it;
+         if (attribute.IsPresent(self, accessible, childId)) {
+            NSString *name = attribute.name;
+            if (otherAttributes && [otherAttributes containsObject: name])
+               // don't duplicate
+               continue;
+            [result addObject: name];
+         }
+      }
+      return result;
+   }
+
+   // Useful, still abstract, subclass of wxNSAccessibilityAttribute
+   // helps to implement other parts of the protocol that query only the
+   // size or a sub-range of the arrays.
+   struct wxNSAccessibilityArrayAttribute : wxNSAccessibilityAttribute
+   {
+      explicit
+      wxNSAccessibilityArrayAttribute(NSString *name)
+      : wxNSAccessibilityAttribute(name)
+      {}
+
+      virtual unsigned GetCount
+      (id element, wxAccessible &accessible, int childID) const = 0;
+
+      virtual id GetArrayElement
+      (id element, wxAccessible &accessible, int childID,
+       unsigned index) const = 0;
+
+      NSUInteger IndexOfValue
+      (id element, wxAccessible &accessible, int childID, id value) const
+      {
+         unsigned count = GetCount(element, accessible, childID);
+         for (unsigned index = 0; index < count; ++index)
+         {
+            id arrayElement =
+            GetArrayElement(element, accessible, childID, index);
+            if ([value isEqual: arrayElement])
+               return index;
+         }
+         return NSNotFound;
+      }
+
+      id GetValues
+      (id element, wxAccessible &accessible, int childID,
+       unsigned index, unsigned maxCount) const
+      {
+         if (maxCount == 0)
+            return [NSArray array];
+
+         NSMutableArray *result =
+         [NSMutableArray arrayWithCapacity: (NSUInteger)maxCount];
+
+         unsigned limit = index + maxCount;
+         while (index < limit)
+         {
+            id arrayElement =
+            GetArrayElement(element, accessible, childID, index);
+            if (arrayElement)
+               [result addObject: arrayElement];
+            ++index;
+         }
+         return result;
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         unsigned count = GetCount(element, accessible, childID);
+         return GetValues(element, accessible, childID, 0, count);
+      }
+   };
+
+   struct wxNAccessibilityStringAttribute : wxNSAccessibilityAttribute
+   {
+      typedef wxAccStatus (wxAccessible::*PMF)(int, wxString*);
+
+      wxNAccessibilityStringAttribute(NSString *name_, PMF pmf_)
+      : wxNSAccessibilityAttribute(name_)
+      , pmf(pmf_)
+      {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxString str;
+         return (wxACC_OK == (accessible.*pmf)(childID, &str));
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxString result;
+         if (wxACC_OK == (accessible.*pmf)(childID, &result))
+            return (id) wxNSStringWithWxString(result);
+         else
+            return @"";
+      }
+
+      const PMF pmf;
+   };
+
+   template <
+      unsigned long StateFlag, bool StateFlagState,
+      unsigned long SettableFlag, bool SettableFlagState,
+      wxAccSelectionFlags SelectFlag
+   > struct wxNSAccessibilityStateAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityStateAttribute(NSString *name)
+      : wxNSAccessibilityAttribute(name)
+      {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id Get
+      (id, wxAccessible &accessible, int childID) const
+      {
+         BOOL result = NO;
+         long state = 0;
+         wxAccStatus status = accessible.GetState(childID, &state);
+         if (wxACC_OK == status &&
+             StateFlagState == !!(state & StateFlag))
+            result = YES;
+         return [NSNumber numberWithBool: result];
+      }
+
+      virtual bool IsSettable
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         long state = 0;
+         wxAccStatus status = accessible.GetState(childID, &state);
+         return
+         (wxACC_OK == status &&
+          SettableFlagState == !!(state & SettableFlag));
+      }
+
+      virtual void Set
+      (id element, wxAccessible &accessible, int childID, id value) const
+      {
+         wxAccStatus status = accessible.Select(childID, SelectFlag);
+         WXUNUSED(status);
+      }
+   };
+
+   // To do: for each of these attributes that is important, make a static
+   // object of a subclass of wxNSAccessibilityAttribute that gets and sets it.
+
+   /* Standard attributes
+    */
+
+   struct wxNSAccessibilityRoleAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityRoleAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityRoleAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         // Standard NSAccessibility roles that did not obviously correspond
+         // to any of the wxROLE constants
+         /*
+          NSAccessibilityTextAreaRole;
+          NSAccessibilityScrollAreaRole;
+          NSAccessibilityRadioGroupRole;
+          NSAccessibilityBusyIndicatorRole;
+          NSAccessibilityDrawerRole;
+          NSAccessibilitySystemWideRole;
+          NSAccessibilityBrowserRole;
+          NSAccessibilitySplitGroupRole;
+          NSAccessibilityColorWellRole;
+          NSAccessibilityMatteRole;
+          NSAccessibilityRulerRole;
+          NSAccessibilityRulerMarkerRole;
+          NSAccessibilityRelevanceIndicatorRole;
+          NSAccessibilityLevelIndicatorRole;
+
+          NSAccessibilityLayoutItemRole;
+
+          NSAccessibilityGridRole;
+          */
+
+         wxAccRole role;
+         if (wxACC_OK == accessible.GetRole(childID, &role)) switch (role)
+         {
+            case wxROLE_SYSTEM_ANIMATION:
+               return NSAccessibilityImageRole; // ??
+
+            case wxROLE_SYSTEM_APPLICATION:
+               return NSAccessibilityApplicationRole;
+
+            case wxROLE_SYSTEM_BORDER:
+               return NSAccessibilityGrowAreaRole; // ??
+
+            case wxROLE_SYSTEM_BUTTONDROPDOWN:
+            case wxROLE_SYSTEM_BUTTONDROPDOWNGRID:
+               return NSAccessibilityPopUpButtonRole;
+
+            case wxROLE_SYSTEM_BUTTONMENU:
+               return NSAccessibilityMenuButtonRole;
+
+            case wxROLE_SYSTEM_CELL:
+               return NSAccessibilityCellRole;
+
+            case wxROLE_SYSTEM_CHART:
+               return NSAccessibilityImageRole; // ??
+
+            case wxROLE_SYSTEM_CHECKBUTTON:
+               return NSAccessibilityCheckBoxRole;
+
+            case wxROLE_SYSTEM_COLUMN:
+            case wxROLE_SYSTEM_COLUMNHEADER:
+               return NSAccessibilityColumnRole;
+
+            case wxROLE_SYSTEM_COMBOBOX:
+               return NSAccessibilityComboBoxRole;
+
+            case wxROLE_SYSTEM_DIAGRAM:
+               return NSAccessibilityImageRole; // ??
+
+            case wxROLE_SYSTEM_DIAL:
+               return NSAccessibilitySliderRole; //??
+
+            case wxROLE_SYSTEM_DIALOG:
+               return NSAccessibilitySheetRole;
+
+            case wxROLE_SYSTEM_DOCUMENT:
+               return NSAccessibilityTextAreaRole; // ??
+
+            case wxROLE_SYSTEM_DROPLIST:
+               return NSAccessibilityMenuRole; // ??
+
+            case wxROLE_SYSTEM_GRAPHIC:
+               return NSAccessibilityImageRole;
+
+            case wxROLE_SYSTEM_GRIP:
+               return NSAccessibilityHandleRole;
+
+            case wxROLE_SYSTEM_GROUPING:
+               return NSAccessibilityGroupRole;
+
+            case wxROLE_SYSTEM_HELPBALLOON:
+               return NSAccessibilityHelpTagRole;
+
+            case wxROLE_SYSTEM_HOTKEYFIELD:
+               return NSAccessibilityTextFieldRole; // ??
+
+            case wxROLE_SYSTEM_INDICATOR:
+               return NSAccessibilityValueIndicatorRole;
+
+            case wxROLE_SYSTEM_LINK:
+               return NSAccessibilityLinkRole;
+
+            case wxROLE_SYSTEM_LIST:
+               return NSAccessibilityListRole;
+
+            case wxROLE_SYSTEM_LISTITEM:
+               return NSAccessibilityMenuItemRole; // ??
+
+            case wxROLE_SYSTEM_MENUBAR:
+               return NSAccessibilityMenuBarRole;
+
+            case wxROLE_SYSTEM_MENUITEM:
+               return NSAccessibilityMenuItemRole;
+
+            case wxROLE_SYSTEM_MENUPOPUP:
+               return NSAccessibilityMenuRole;
+
+            case wxROLE_SYSTEM_OUTLINE:
+               return NSAccessibilityOutlineRole;
+
+            case wxROLE_SYSTEM_OUTLINEITEM:
+               return NSAccessibilityDisclosureTriangleRole; // ??
+
+            case wxROLE_SYSTEM_PAGETAB:
+               return NSAccessibilityButtonRole; // ???
+
+            case wxROLE_SYSTEM_PAGETABLIST:
+               return NSAccessibilityTabGroupRole; // ??
+
+            case wxROLE_SYSTEM_PANE:
+               return NSAccessibilityLayoutAreaRole; // ??
+
+            case wxROLE_SYSTEM_PROGRESSBAR:
+               return NSAccessibilityProgressIndicatorRole;
+
+            case wxROLE_SYSTEM_PROPERTYPAGE:
+               return NSAccessibilitySheetRole; // ??
+
+            case wxROLE_SYSTEM_PUSHBUTTON:
+               return NSAccessibilityButtonRole;
+
+            case wxROLE_SYSTEM_RADIOBUTTON:
+               return NSAccessibilityRadioButtonRole;
+
+            case wxROLE_SYSTEM_ROWHEADER:
+            case wxROLE_SYSTEM_ROW:
+               return NSAccessibilityRowRole;
+
+            case wxROLE_SYSTEM_SCROLLBAR:
+               return NSAccessibilityScrollBarRole;
+
+            case wxROLE_SYSTEM_SEPARATOR:
+               return NSAccessibilitySplitterRole; // ??
+
+            case wxROLE_SYSTEM_SLIDER:
+               return NSAccessibilitySliderRole;
+
+            case wxROLE_SYSTEM_SPINBUTTON:
+               return NSAccessibilityIncrementorRole;
+
+            case wxROLE_SYSTEM_STATICTEXT:
+               return NSAccessibilityStaticTextRole;
+
+            case wxROLE_SYSTEM_STATUSBAR:
+               return NSAccessibilityStaticTextRole; // ??
+
+            case wxROLE_SYSTEM_TABLE:
+               return NSAccessibilityTableRole;
+
+            case wxROLE_SYSTEM_TEXT:
+               return NSAccessibilityTextFieldRole;
+
+            case wxROLE_SYSTEM_TITLEBAR:
+               return NSAccessibilityStaticTextRole; // ??
+
+            case wxROLE_SYSTEM_TOOLBAR:
+               return NSAccessibilityToolbarRole;
+
+            case wxROLE_SYSTEM_TOOLTIP:
+               return NSAccessibilityHelpTagRole; // ??
+
+            case wxROLE_SYSTEM_WHITESPACE:
+               return NSAccessibilityStaticTextRole; // ??
+
+            case wxROLE_SYSTEM_WINDOW:
+               return NSAccessibilityWindowRole;
+
+               // wxROLE constants that did not correspond to anything obvious
+               // in the list of standard NSAccessibility roles
+            case wxROLE_NONE:
+            case wxROLE_SYSTEM_ALERT:
+            case wxROLE_SYSTEM_CARET:
+            case wxROLE_SYSTEM_CHARACTER:
+            case wxROLE_SYSTEM_CLIENT:
+            case wxROLE_SYSTEM_CLOCK:
+            case wxROLE_SYSTEM_CURSOR:
+            case wxROLE_SYSTEM_EQUATION:
+            case wxROLE_SYSTEM_SOUND:
+            default:
+               return NSAccessibilityUnknownRole;
+         }
+         else
+            return NSAccessibilityUnknownRole;
+      }
+   } swxNSAccessibilityRoleAttribute;
+
+   struct wxNSAccessibilitySubroleAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilitySubroleAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilitySubroleAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         // Improve this
+         return NSAccessibilityUnknownSubrole;
+      }
+   } swxNSAccessibilitySubroleAttribute;
+
+   struct wxNSAccessibilityRoleDescriptionAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityRoleDescriptionAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityRoleDescriptionAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         id role =
+         swxNSAccessibilityRoleAttribute.Get(element, accessible, childID);
+         id subRole =
+         swxNSAccessibilitySubroleAttribute.Get(element, accessible, childID);
+         NSString *result =
+         NSAccessibilityRoleDescription((NSString*)role, (NSString*)subRole);
+         return result;
+      }
+   } swxNSAccessibilityRoleDescriptionAttribute;
+
+   wxNAccessibilityStringAttribute sxwNSAccessibilityHelpAttribute
+      (NSAccessibilityHelpAttribute, &wxAccessible::GetHelpText);
+
+   // Not different from value -- is that right?
+   wxNAccessibilityStringAttribute sxwNSAccessibilityValueAttribute
+      (NSAccessibilityValueAttribute, &wxAccessible::GetValue);
+
+#if 0
+   NSAccessibilityMinValueAttribute;		//(id)         - element's min value
+   NSAccessibilityMaxValueAttribute;		//(id)         - element's max value
 #endif
 
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_UNAVAILABLE, false,
+      0, true, wxACC_SEL_NONE // not settable
+   > swxNSAccessibilityEnabledAttribute(NSAccessibilityEnabledAttribute);
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_FOCUSED, true,
+      wxACC_STATE_SYSTEM_FOCUSABLE, true,
+      wxACC_SEL_TAKEFOCUS
+   > swxNSAccessibilityFocusedAttribute(NSAccessibilityFocusedAttribute);
+
+   struct wxNSAccessibilityParentAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityParentAttribute()
+      : wxNSAccessibilityAttribute(NSAccessibilityParentAttribute)
+      {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return nil != Get(element, accessible, childID);
+      }
+
+      virtual id Get
+      (id, wxAccessible &accessible, int childID) const
+      {
+         // I'm not using wxAccessible::GetParent() because the default
+         // implementation has the undesirable side effect of creating
+         // wxAccessible objects for windows that did not already have them.
+
+         wxWindow *window = accessible.GetWindow();
+
+         if (childID != wxACC_SELF)
+            // report parent of non-window accessible element
+            return window->GetPeer()->GetWXWidget();
+
+         // Report direct parent window if that defines a wxAccessible
+         wxWindow *parent = window->GetParent();
+         if (parent && parent->GetAccessible())
+         {
+            NSObject *widget = parent->GetPeer()->GetWXWidget();
+            return widget;
+         }
+
+         // Cause defaulting to the framework's definition of parent
+         return nil;
+      }
+   } swxNSAccessibilityParentAttribute;
+
+   //(NSArray *)  - elements you contain
+   struct wxNSAccessibilityChildrenAttributeBase : wxNSAccessibilityArrayAttribute
+   {
+      wxNSAccessibilityChildrenAttributeBase(NSString *name_)
+      : wxNSAccessibilityArrayAttribute(name_)
+      {}
+
+      virtual bool Condition
+         (wxAccessible &accessible, int childID,
+          wxAccessible *pChild) const = 0;
+
+      virtual bool IsPresent
+         (id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual unsigned GetCount
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         if (childID != 0)
+            return 0;
+
+         int childCount;
+         wxAccStatus status = accessible.GetChildCount(&childCount);
+         if (status != wxACC_OK || childCount <= 0)
+            return 0;
+         else
+            return childCount;
+      }
+
+      virtual id GetArrayElement
+      (id element, wxAccessible &accessible, int childID,
+       unsigned index) const
+      {
+         if (childID != 0)
+            return nil;
+
+         wxAccessible *child = NULL;
+         wxAccStatus status = accessible.GetChild(index + 1, &child);
+         if (status != wxACC_OK)
+            return nil;
+
+         if (!Condition(accessible, index + 1, child))
+            return nil;
+
+         return GetUIElement(accessible, index + 1, child);
+      }
+   };
+
+   struct wxNSAccessibilityChildrenAttribute
+   : wxNSAccessibilityChildrenAttributeBase
+   {
+      explicit
+      wxNSAccessibilityChildrenAttribute
+         (NSString *attr = NSAccessibilityChildrenAttribute)
+      : wxNSAccessibilityChildrenAttributeBase(attr)
+      {}
+
+      virtual bool Condition(wxAccessible &, int, wxAccessible *) const
+      {
+         return true;
+      }
+
+   } swxNSAccessibilityChildrenAttribute;
+
+   struct wxNSAccessibilityWindowAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityWindowAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityWindowAttribute) {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return true;
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxWindow *pWindow = accessible.GetWindow(), *pParent;
+         while (!dynamic_cast<wxNonOwnedWindow*>(pWindow) &&
+            NULL != (pParent = pWindow->GetParent()))
+            pWindow = pParent;
+         NSObject *widget = pWindow->GetPeer()->GetWXWidget();
+         return widget;
+      }
+   } swxNSAccessibilityWindowAttribute;
+
+   struct wxNSAccessibilityTopLevelUIAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityTopLevelUIAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityTopLevelUIElementAttribute) {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return false;
+      }
+
+      virtual id Get
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         return element;
+         /*
+         id prevElement = element, newElement;
+         do try {
+            newElement =
+               [element accessibilityAttributeValue: NSAccessibilityParentAttribute];
+         }
+         catch(...) {
+            return prevElement;
+         }
+         while (newElement != NULL &&
+                (prevElement = element, element = newElement));
+         return element;
+          */
+      }
+   } swxNSAccessibilityTopLevelUIAttribute;
+
+   struct wxNSAccessibilitySelectedChildrenAttribute
+   : wxNSAccessibilityChildrenAttributeBase
+   {
+      explicit
+      wxNSAccessibilitySelectedChildrenAttribute
+         (NSString *attr = NSAccessibilitySelectedChildrenAttribute)
+      : wxNSAccessibilityChildrenAttributeBase(attr)
+      {}
+
+      virtual bool Condition
+      (wxAccessible &accessible, int childID,
+       wxAccessible *pChild) const
+      {
+         wxAccStatus status;
+         long state = 0;
+         if (pChild)
+            status = pChild->GetState(wxACC_SELF, &state);
+         else
+            status = accessible.GetState(childID, &state);
+
+         return (status == wxACC_OK &&
+                 0 != (state & wxACC_STATE_SYSTEM_SELECTED));
+      }
+   } swxNSAccessibilitySelectedChildrenAttribute;
+
+   struct wxNSAccessibilityVisibleChildrenAttribute
+   : wxNSAccessibilityChildrenAttributeBase
+   {
+      explicit
+      wxNSAccessibilityVisibleChildrenAttribute
+         (NSString *attr = NSAccessibilityVisibleChildrenAttribute)
+      : wxNSAccessibilityChildrenAttributeBase(attr)
+      {}
+
+      virtual bool Condition
+      (wxAccessible &accessible, int childID,
+       wxAccessible *pChild) const
+      {
+         wxAccStatus status;
+         long state = 0;
+         if (pChild)
+            status = pChild->GetState(wxACC_SELF, &state);
+         else
+            status = accessible.GetState(childID, &state);
+
+         return (status == wxACC_OK &&
+                 0 == (state & wxACC_STATE_SYSTEM_INVISIBLE));
+      }
+   } swxNSAccessibilityVisibleChildrenAttribute;
+
+   struct wxNSAccessibilityPositionAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilityPositionAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilityPositionAttribute) {}
+
+      virtual bool IsPresent
+      (id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         return (wxACC_OK == accessible.GetLocation(rect, childID));
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         NSPoint point = { 0, 0 };
+         if (wxACC_OK == accessible.GetLocation(rect, childID))
+         {
+            int height;
+            ::wxDisplaySize(NULL, &height);
+            point.x = rect.x, point.y = height - rect.y - rect.height;
+         }
+         return [NSValue valueWithBytes: &point objCType: @encode(NSPoint)];
+      }
+   } swxNSAccessibilityPositionAttribute;
+
+   struct wxNSAccessibilitySizeAttribute : wxNSAccessibilityAttribute
+   {
+      wxNSAccessibilitySizeAttribute ()
+      : wxNSAccessibilityAttribute(NSAccessibilitySizeAttribute) {}
+
+      virtual bool
+      IsPresent(id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         return (wxACC_OK == accessible.GetLocation(rect, childID));
+      }
+
+      virtual id
+      Get(id element, wxAccessible &accessible, int childID) const
+      {
+         wxRect rect;
+         NSSize size = { 0, 0 };
+         if (wxACC_OK == accessible.GetLocation(rect, childID))
+            size.width = rect.width, size.height = rect.height;
+         return [NSValue valueWithBytes: &size objCType: @encode(NSSize)];
+      }
+   } swxNSAccessibilitySizeAttribute;
+
+   // Make "contents" no different from "children" -- is that right?
+   wxNSAccessibilityChildrenAttribute
+      swxNSAccessibilityContentsAttribute(NSAccessibilityContentsAttribute);
+
+   wxNAccessibilityStringAttribute sxwNSAccessibilityTitleAttribute
+      (NSAccessibilityTitleAttribute, &wxAccessible::GetName);
+   wxNAccessibilityStringAttribute sxwNSAccessibilityDescriptionAttribute
+      (NSAccessibilityDescriptionAttribute, &wxAccessible::GetDescription);
+
+#if 0
+   NSAccessibilityShownMenuAttribute		//(id)         - menu being displayed
+   ;
+#endif
+
+   wxNAccessibilityStringAttribute sxwNSAccessibilityValueDescriptionAttribute
+      (NSAccessibilityValueDescriptionAttribute, &wxAccessible::GetValue);
+
+#if 0
+   /* Misc attributes
+    */
+   NSAccessibilityPreviousContentsAttribute;	//(NSArray *)  - main elements
+   NSAccessibilityNextContentsAttribute;	//(NSArray *)  - main elements
+   NSAccessibilityHeaderAttribute;		//(id)         - UIElement for header.
+   NSAccessibilityEditedAttribute;		//(NSNumber *) - (boolValue) is it dirty?
+   NSAccessibilityTabsAttribute;		//(NSArray *)  - UIElements for tabs
+   NSAccessibilityHorizontalScrollBarAttribute;//(id)       - UIElement for the horizontal scroller
+   NSAccessibilityVerticalScrollBarAttribute;//(id)         - UIElement for the vertical scroller
+   NSAccessibilityOverflowButtonAttribute;	//(id)         - UIElement for overflow
+   NSAccessibilityIncrementButtonAttribute;	//(id)         - UIElement for increment
+   NSAccessibilityDecrementButtonAttribute;	//(id)         - UIElement for decrement
+   NSAccessibilityFilenameAttribute;		//(NSString *) - filename
+#endif
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_EXPANDED, true,
+      0, true, wxACC_SEL_NONE // not settable
+   > swxNSAccessibilityExpandedAttribute(NSAccessibilityExpandedAttribute);
+
+   wxNSAccessibilityStateAttribute <
+      wxACC_STATE_SYSTEM_SELECTED, true,
+      wxACC_STATE_SYSTEM_SELECTABLE, true,
+      wxACC_SEL_TAKESELECTION
+   > swxNSAccessibilitySelectedAttribute(NSAccessibilitySelectedAttribute);
+
+#if 0
+   NSAccessibilitySplittersAttribute;	//(NSArray *)  - UIElements for splitters
+   NSAccessibilityDocumentAttribute;		//(NSString *) - url as string - for open document
+   NSAccessibilityURLAttribute		//(NSURL *)    - url
+   ;
+   NSAccessibilityIndexAttribute		//(NSNumber *)  - (intValue)
+   ;
+
+   NSAccessibilityRowCountAttribute		//(NSNumber *)  - (intValue) number of rows
+   ;
+   NSAccessibilityColumnCountAttribute	//(NSNumber *)  - (intValue) number of columns
+   ;
+   NSAccessibilityOrderedByRowAttribute	//(NSNumber *)  - (boolValue) is ordered by row?
+   ;
+
+   NSAccessibilityWarningValueAttribute	//(id)  - warning value of a level indicator, typically a number
+   ;
+   NSAccessibilityCriticalValueAttribute	//(id)  - critical value of a level indicator, typically a number
+   ;
+   NSAccessibilityPlaceholderValueAttribute	//(NSString *)  - placeholder value of a control such as a text field
+   ;
+
+   /* Linkage attributes
+    */
+   NSAccessibilityTitleUIElementAttribute;		//(id)	      - UIElement for the title
+   NSAccessibilityServesAsTitleForUIElementsAttribute//(NSArray *) - UIElements this titles
+   ;
+   NSAccessibilityLinkedUIElementsAttribute		//(NSArray *) - corresponding UIElements
+   ;
+
+
+   /* Text-specific attributes
+    */
+   NSAccessibilitySelectedTextAttribute;		//(NSString *) - selected text
+   NSAccessibilitySelectedTextRangeAttribute;	//(NSValue *)  - (rangeValue) range of selected text
+   NSAccessibilityNumberOfCharactersAttribute	//(NSNumber *) - number of characters
+   ;
+   NSAccessibilityVisibleCharacterRangeAttribute	//(NSValue *)  - (rangeValue) range of visible text
+   ;
+   NSAccessibilitySharedTextUIElementsAttribute	//(NSArray *)  - text views sharing text
+   ;
+   NSAccessibilitySharedCharacterRangeAttribute	//(NSValue *)  - (rangeValue) part of shared text in this view
+   ;
+   NSAccessibilityInsertionPointLineNumberAttribute	//(NSNumber *) - line# containing caret
+   ;
+   NSAccessibilitySelectedTextRangesAttribute	//(NSArray *) - array of NSValue (rangeValue) ranges of selected text
+   ;
+
+
+   /* Parameterized text-specific attributes
+    */
+   NSAccessibilityLineForIndexParameterizedAttribute		//(NSNumber *) - line# for char index; param:(NSNumber *)
+   ;
+   NSAccessibilityRangeForLineParameterizedAttribute		//(NSValue *)  - (rangeValue) range of line; param:(NSNumber *)
+   ;
+   NSAccessibilityStringForRangeParameterizedAttribute	//(NSString *) - substring; param:(NSValue * - rangeValue)
+   ;
+   NSAccessibilityRangeForPositionParameterizedAttribute	//(NSValue *)  - (rangeValue) composed char range; param:(NSValue * - pointValue)
+   ;
+   NSAccessibilityRangeForIndexParameterizedAttribute	//(NSValue *)  - (rangeValue) composed char range; param:(NSNumber *)
+   ;
+   NSAccessibilityBoundsForRangeParameterizedAttribute	//(NSValue *)  - (rectValue) bounds of text; param:(NSValue * - rangeValue)
+   ;
+   NSAccessibilityRTFForRangeParameterizedAttribute		//(NSData *)   - rtf for text; param:(NSValue * - rangeValue)
+   ;
+   NSAccessibilityStyleRangeForIndexParameterizedAttribute	//(NSValue *)  - (rangeValue) extent of style run; param:(NSNumber *)
+   ;
+   NSAccessibilityAttributedStringForRangeParameterizedAttribute //(NSAttributedString *) - does _not_ use attributes from Appkit/AttributedString.h
+   ;
+
+
+   /* Text attributed string attributes and constants
+    */
+   NSAccessibilityFontTextAttribute			//(NSDictionary *)  - NSAccessibilityFontXXXKey's
+   ;
+   NSAccessibilityForegroundColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityBackgroundColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityUnderlineColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityStrikethroughColorTextAttribute	//CGColorRef
+   ;
+   NSAccessibilityUnderlineTextAttribute		//(NSNumber *)	    - underline style
+   ;
+   NSAccessibilitySuperscriptTextAttribute		//(NSNumber *)	    - superscript>0, subscript<0
+   ;
+   NSAccessibilityStrikethroughTextAttribute		//(NSNumber *)	    - (boolValue)
+   ;
+   NSAccessibilityShadowTextAttribute		//(NSNumber *)	    - (boolValue)
+   ;
+   NSAccessibilityAttachmentTextAttribute		//id - corresponding element
+   ;
+   NSAccessibilityLinkTextAttribute			//id - corresponding element
+   ;
+   NSAccessibilityMisspelledTextAttribute		//(NSNumber *)	    - (boolValue)
+   ;
+
+   NSAccessibilityFontNameKey	// required
+   ;
+   NSAccessibilityFontFamilyKey	// optional
+   ;
+   NSAccessibilityVisibleNameKey	// optional
+   ;
+   NSAccessibilityFontSizeKey	// required
+   ;
+
+
+   /* Window-specific attributes
+    */
+   NSAccessibilityMainAttribute;		//(NSNumber *) - (boolValue) is it the main window?
+   NSAccessibilityMinimizedAttribute;	//(NSNumber *) - (boolValue) is window minimized?
+   NSAccessibilityCloseButtonAttribute;	//(id) - UIElement for close box (or nil)
+   NSAccessibilityZoomButtonAttribute;	//(id) - UIElement for zoom box (or nil)
+   NSAccessibilityMinimizeButtonAttribute;	//(id) - UIElement for miniaturize box (or nil)
+   NSAccessibilityToolbarButtonAttribute;	//(id) - UIElement for toolbar box (or nil)
+   NSAccessibilityProxyAttribute;		//(id) - UIElement for title's icon (or nil)
+   NSAccessibilityGrowAreaAttribute;		//(id) - UIElement for grow box (or nil)
+   NSAccessibilityModalAttribute		//(NSNumber *) - (boolValue) is the window modal
+   ;
+   NSAccessibilityDefaultButtonAttribute	//(id) - UIElement for default button
+   ;
+   NSAccessibilityCancelButtonAttribute	//(id) - UIElement for cancel button
+   ;
+
+   /* Application-specific attributes
+    */
+   NSAccessibilityMenuBarAttribute;		//(id)         - UIElement for the menu bar
+   NSAccessibilityWindowsAttribute;		//(NSArray *)  - UIElements for the windows
+   NSAccessibilityFrontmostAttribute;	//(NSNumber *) - (boolValue) is the app active?
+   NSAccessibilityHiddenAttribute;		//(NSNumber *) - (boolValue) is the app hidden?
+   NSAccessibilityMainWindowAttribute;	//(id)         - UIElement for the main window.
+   NSAccessibilityFocusedWindowAttribute;	//(id)         - UIElement for the key window.
+   NSAccessibilityFocusedUIElementAttribute;	//(id)         - Currently focused UIElement.
+
+   NSAccessibilityOrientationAttribute;	//(NSString *) - NSAccessibilityXXXOrientationValue
+   NSAccessibilityVerticalOrientationValue;
+   NSAccessibilityHorizontalOrientationValue;
+   NSAccessibilityUnknownOrientationValue	;
+
+   NSAccessibilityColumnTitlesAttribute;	//(NSArray *)  - UIElements for titles
+
+   NSAccessibilitySearchButtonAttribute	//(id)         - UIElement for search field search btn
+   ;
+   NSAccessibilitySearchMenuAttribute	//(id)         - UIElement for search field menu
+   ;
+   NSAccessibilityClearButtonAttribute	//(id)         - UIElement for search field clear btn
+   ;
+
+
+   /* Table/outline view attributes
+    */
+   NSAccessibilityRowsAttribute;		//(NSArray *)  - UIElements for rows
+   NSAccessibilityVisibleRowsAttribute;	//(NSArray *)  - UIElements for visible rows
+   NSAccessibilitySelectedRowsAttribute;	//(NSArray *)  - UIElements for selected rows
+   NSAccessibilityColumnsAttribute;		//(NSArray *)  - UIElements for columns
+   NSAccessibilityVisibleColumnsAttribute;	//(NSArray *)  - UIElements for visible columns
+   NSAccessibilitySelectedColumnsAttribute;	//(NSArray *)  - UIElements for selected columns
+   NSAccessibilitySortDirectionAttribute	//(NSString *) - see sort direction values below
+   ;
+
+   /* Cell-based table attributes
+    */
+   NSAccessibilitySelectedCellsAttribute ;	//(NSArray *)  - UIElements for selected cells
+   NSAccessibilityVisibleCellsAttribute ;	//(NSArray *)  - UIElements for visible cells
+   NSAccessibilityRowHeaderUIElementsAttribute ;	//(NSArray *)  - UIElements for row headers
+   NSAccessibilityColumnHeaderUIElementsAttribute ;	//(NSArray *)  - UIElements for column headers
+
+   /* Cell-based table parameterized attributes.  The parameter for this attribute is an NSArray containing two NSNumbers, the first NSNumber specifies the column index, the second NSNumber specifies the row index.
+    */
+   NSAccessibilityCellForColumnAndRowParameterizedAttribute ;  // (id) - UIElement for cell at specified row and column
+
+   /* Cell attributes.  The index range contains both the starting index, and the index span in a table.
+    */
+   NSAccessibilityRowIndexRangeAttribute ;	//(NSValue *)  - (rangeValue) location and row span
+   NSAccessibilityColumnIndexRangeAttribute ;   //(NSValue *)  - (rangeValue) location and column span
+
+   /* Layout area attributes
+    */
+   NSAccessibilityHorizontalUnitsAttribute ;   //(NSString *) - see ruler unit values below
+   NSAccessibilityVerticalUnitsAttribute ;	    //(NSString *) - see ruler unit values below
+   NSAccessibilityHorizontalUnitDescriptionAttribute ; //(NSString *)
+   NSAccessibilityVerticalUnitDescriptionAttribute ;    //(NSString *)
+
+   /* Layout area parameterized attributes
+    */
+   NSAccessibilityLayoutPointForScreenPointParameterizedAttribute ; //(NSValue *)  - (pointValue); param:(NSValue * - pointValue)
+   NSAccessibilityLayoutSizeForScreenSizeParameterizedAttribute ; //(NSValue *)  - (sizeValue); param:(NSValue * - sizeValue)
+   NSAccessibilityScreenPointForLayoutPointParameterizedAttribute ; //(NSValue *)  - (pointValue); param:(NSValue * - pointValue)
+   NSAccessibilityScreenSizeForLayoutSizeParameterizedAttribute ; //(NSValue *)  - (sizeValue); param:(NSValue * - sizeValue)
+
+   /* Layout item attributes
+    */
+   NSAccessibilityHandlesAttribute ; //(NSArray *)  - UIElements for handles
+
+   /* Sort direction values
+    */
+   NSAccessibilityAscendingSortDirectionValue	;
+   NSAccessibilityDescendingSortDirectionValue	;
+   NSAccessibilityUnknownSortDirectionValue		;
+
+   /* Outline attributes
+    */
+   NSAccessibilityDisclosingAttribute;	//(NSNumber *) - (boolValue) is diclosing rows?
+   NSAccessibilityDisclosedRowsAttribute;	//(NSArray *)  - UIElements for disclosed rows
+   NSAccessibilityDisclosedByRowAttribute;	//(id)         - UIElement for disclosing row
+   NSAccessibilityDisclosureLevelAttribute	//(NSNumber *) - indentation level
+   ;
+
+   /* Slider attributes
+    */
+   NSAccessibilityAllowedValuesAttribute	//(NSArray *) - array of allowed values
+   ;
+   NSAccessibilityLabelUIElementsAttribute	//(NSArray *) - array of label UIElements
+   ;
+   NSAccessibilityLabelValueAttribute	//(NSNumber *) - value of a label UIElement
+   ;
+
+   /* Matte attributes
+    */
+   NSAccessibilityMatteHoleAttribute		//(NSValue *) - (rect value) bounds of matte hole in screen coords
+   ;
+   NSAccessibilityMatteContentUIElementAttribute //(id) - UIElement clipped by the matte
+   ;
+
+   /* Ruler view attributes
+    */
+   NSAccessibilityMarkerUIElementsAttribute		//(NSArray *)
+   ;
+   NSAccessibilityMarkerValuesAttribute		//
+   ;
+   NSAccessibilityMarkerGroupUIElementAttribute	//(id)
+   ;
+   NSAccessibilityUnitsAttribute			//(NSString *) - see ruler unit values below
+   ;
+   NSAccessibilityUnitDescriptionAttribute		//(NSString *)
+   ;
+   NSAccessibilityMarkerTypeAttribute		//(NSString *) - see ruler marker type values below
+   ;
+   NSAccessibilityMarkerTypeDescriptionAttribute	//(NSString *)
+   ;
+
+   /* Deprecated
+    */
+   NSAccessibilityHorizontialUnitsAttribute ;
+   NSAccessibilityHorizontialUnitDescriptionAttribute ;
+#endif
+
+}
+
+NSArray *wxOSX_accessibilityAttributeNames( id self, SEL _cmd )
+{
+   // Pass-through first
+   typedef NSArray *(*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd);
+
+   // Add more attributes
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+      return findAttributeNames( self, *accessible, wxACC_SELF, result );
+
+   return result;
+}
+
+id wxOSX_accessibilityAttributeValue( id self, SEL _cmd, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+         findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+         return pAttribute->Get(self, *accessible, wxACC_SELF);
+   }
+
+   // Otherwise, pass-through
+   typedef id (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+BOOL wxOSX_accessibilityIsAttributeSettable( id self, SEL _cmd, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+         findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+         return pAttribute->IsSettable(self, *accessible, wxACC_SELF);
+   }
+
+   // Otherwise, pass-through
+   typedef BOOL (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   BOOL result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+void wxOSX_accessibilitySetValue_forAttribute( id self, SEL _cmd, id value, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+         findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+      {
+         if (pAttribute->IsSettable(self, *accessible, wxACC_SELF))
+            pAttribute->Set(self, *accessible, wxACC_SELF, value);
+         return;
+      }
+   }
+
+   // Otherwise, pass-through
+   typedef void (*Function)(id, SEL, id, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   superimpl(self, _cmd, value, attribute);
+}
+
+NSArray *wxOSX_accessibilityParameterizedAttributeNames( id self, SEL _cmd )
+{
+   typedef NSArray *(*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd);
+   return result;
+}
+
+id wxOSX_accessibilityAttributeValue_forParameter
+   ( id self, SEL _cmd, NSString *attribute, id parameter )
+{
+   typedef id (*Function)(id, SEL, NSString*, id);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd, attribute, parameter);
+   return result;
+}
+
+NSArray *wxOSX_accessibilityActionNames( id self, SEL _cmd )
+{
+#if 0
+   /* Actions
+    */
+NSAccessibilityPressAction;
+NSAccessibilityIncrementAction;
+NSAccessibilityDecrementAction;
+NSAccessibilityConfirmAction;
+NSAccessibilityPickAction;
+NSAccessibilityCancelAction;
+NSAccessibilityRaiseAction;
+NSAccessibilityShowMenuAction;
+NSAccessibilityDeleteAction;
+#endif
+
+   // This function produces an array of standard action string keys, which are
+   // not localized action descriptions.  So wxAccessible::GetDefaultAction()
+   // is not what we want.
+
+   // So in default of a better thing to do,
+   // we just give everything one press action, and only in case a default
+   // action is defined.
+   wxAccessible *pAccessible = findAccessible(self);
+   if (pAccessible)
+   {
+      wxString unused;
+      wxAccStatus status = pAccessible->GetDefaultAction(wxACC_SELF, &unused);
+      if (status == wxACC_OK)
+      {
+         return [NSArray arrayWithObject: NSAccessibilityPressAction];
+      }
+   }
+
+   typedef NSArray *(*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd);
+   return result;
+}
+
+NSString *wxOSX_accessibilityActionDescription( id self, SEL _cmd, NSString *action )
+{
+   NSString *result = NSAccessibilityActionDescription(action);
+   if (result)
+      return result;
+
+   typedef NSString *(*Function)(id, SEL, NSString*);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   result = superimpl(self, _cmd, action);
+   return result;
+}
+
+void wxOSX_accessibilityPerformAction( id self, SEL _cmd, NSString *action )
+{
+   wxAccessible *pAccessible = findAccessible(self);
+   if (pAccessible)
+   {
+      wxAccStatus status = pAccessible->DoDefaultAction(wxACC_SELF);
+      if (status == wxACC_OK)
+         return;
+   }
+
+   typedef void (*Function)(id, SEL, NSString*);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   superimpl(self, _cmd, action);
+}
+
+BOOL wxOSX_accessibilityIsIgnored( id self, SEL _cmd )
+{
+   wxAccessible *pAccessible = findAccessible(self);
+   if (pAccessible)
+      return NO;
+
+   typedef BOOL (*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   BOOL result = superimpl(self, _cmd);
+   return result;
+}
+
+id wxOSX_accessibilityHitTest( id self, SEL _cmd, NSPoint point )
+{
+   typedef id (*Function)(id, SEL, NSPoint);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd, point);
+   return result;
+}
+
+id wxOSX_accessibilityFocusedUIElement( id self, SEL _cmd )
+{
+   typedef id (*Function)(id, SEL);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   id result = superimpl(self, _cmd);
+   return result;
+}
+
+NSUInteger wxOSX_accessibilityIndexOfChild( id self, SEL _cmd, id child )
+{
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      return swxNSAccessibilityChildrenAttribute
+         .IndexOfValue(self, *accessible, wxACC_SELF, child);
+   }
+
+   typedef NSUInteger (*Function)(id, SEL, id);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSUInteger result = superimpl(self, _cmd, child);
+   return result;
+}
+
+NSUInteger wxOSX_accessibilityArrayAttributeCount( id self, SEL _cmd, NSString *attribute )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+      {
+         const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+            dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+         if (pArrayAttribute)
+         {
+            return pArrayAttribute->GetCount(self, *accessible, wxACC_SELF);
+         }
+      }
+   }
+
+   // Otherwise, pass-through
+   typedef NSUInteger (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSUInteger result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+NSArray *wxOSX_accessibilityArrayAttributeValues_index_maxCount
+   ( id self, SEL _cmd, NSString *attribute, NSUInteger index, NSUInteger maxCount )
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   wxAccessible *accessible = findAccessible( self );
+   if (accessible)
+   {
+      const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+      if (pAttribute && pAttribute->IsPresent(self, *accessible, wxACC_SELF))
+      {
+         const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+         dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+         if (pArrayAttribute)
+         {
+            return pArrayAttribute->GetValues
+               (self, *accessible, wxACC_SELF, index, maxCount);
+         }
+      }
+   }
+
+   // Otherwise, pass-through
+   typedef NSArray *(*Function)(id, SEL, NSString *, NSUInteger, NSUInteger);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   NSArray *result = superimpl(self, _cmd, attribute, index, maxCount);
+   return result;
+}
+
+BOOL wxOSX_accessibilitySetOverrideValue_forAttribute( id self, SEL _cmd, NSString *attribute )
+{
+   typedef BOOL (*Function)(id, SEL, NSString *);
+   Function superimpl = (Function)
+      [[self superclass] instanceMethodForSelector:_cmd];
+   BOOL result = superimpl(self, _cmd, attribute);
+   return result;
+}
+
+
+#endif
+
+NSString* wxOSX_stringValue(id self, SEL _cmd)
+{
+   if ([[self superclass] instancesRespondToSelector: _cmd])
+   {
+      typedef NSString* (*Function)(id, SEL);
+      Function superimpl = (Function)
+         [[self superclass] instanceMethodForSelector:_cmd];
+      return superimpl(self, _cmd);
+   }
+   else
+      return @"";
+}
+
 void wxOSX_mouseEvent(NSView* self, SEL _cmd, NSEvent *event)
 {
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
@@ -1063,7 +2484,7 @@ void wxOSX_cursorUpdate(NSView* self, SEL _cmd, NSEvent *event)
     wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( self );
     if (impl == NULL)
         return;
-    
+
     impl->cursorUpdate(event, self, _cmd);
 }
 
@@ -1236,7 +2657,7 @@ void wxOSX_drawRect(NSView* self, SEL _cmd, NSRect rect)
             wxWindow* win = impl->GetWXPeer();
             if ( win->UseBgCol() )
             {
-                
+
                 CGContextRef context = (CGContextRef) [[NSGraphicsContext currentContext] graphicsPort];
                 CGContextSaveGState( context );
 
@@ -1247,7 +2668,7 @@ void wxOSX_drawRect(NSView* self, SEL _cmd, NSRect rect)
                 CGContextRestoreGState( context );
             }
         }
-        else 
+        else
         {
             // just call the superclass handler, we don't need any custom wx drawing
             // here and it seems to work fine:
@@ -1458,7 +2879,7 @@ void wxWidgetCocoaImpl::mouseEvent(WX_NSEvent event, WXWidget slf, void *_cmd)
         if ( hitview == NULL || hitview != slf)
             return;
     }
-    
+
     if ( !DoHandleMouseEvent(event) )
     {
         // for plain NSView mouse events would propagate to parents otherwise
@@ -1467,19 +2888,19 @@ void wxWidgetCocoaImpl::mouseEvent(WX_NSEvent event, WXWidget slf, void *_cmd)
         {
             wxOSX_EventHandlerPtr superimpl = (wxOSX_EventHandlerPtr) [[slf superclass] instanceMethodForSelector:(SEL)_cmd];
             superimpl(slf, (SEL)_cmd, event);
-            
+
             // super of built-ins keeps the mouse up, as wx expects this event, we have to synthesize it
             // only trigger if at this moment the mouse is already up, and the control is still existing after the event has
             // been handled (we do this by looking up the native NSView's peer from the hash map, that way we are sure the info
             // is current - even when the instance memory of ourselves may have been freed ...
-            
+
             wxWidgetCocoaImpl* impl = (wxWidgetCocoaImpl* ) wxWidgetImpl::FindFromWXWidget( slf );
             if ( [ event type]  == NSLeftMouseDown && !wxGetMouseState().LeftIsDown() && impl != NULL )
             {
                 wxMouseEvent wxevent(wxEVT_LEFT_DOWN);
                 SetupMouseEvent(wxevent , event) ;
                 wxevent.SetEventType(wxEVT_LEFT_UP);
-                
+
                 GetWXPeer()->HandleWindowEvent(wxevent);
             }
         }
@@ -1498,7 +2919,7 @@ void wxWidgetCocoaImpl::cursorUpdate(WX_NSEvent event, WXWidget slf, void *_cmd)
 bool wxWidgetCocoaImpl::SetupCursor(WX_NSEvent event)
 {
     extern wxCursor gGlobalCursor;
-    
+
     if ( gGlobalCursor.IsOk() )
     {
         gGlobalCursor.MacInstall();
@@ -1510,7 +2931,7 @@ bool wxWidgetCocoaImpl::SetupCursor(WX_NSEvent event)
         wxCoord x,y;
         SetupCoordinates(x, y, event);
         wxPoint cursorPoint( x , y ) ;
-        
+
         while ( cursorTarget && !cursorTarget->MacSetupCursor( cursorPoint ) )
         {
             // at least in GTK cursor events are not propagated either ...
@@ -1522,7 +2943,7 @@ bool wxWidgetCocoaImpl::SetupCursor(WX_NSEvent event)
                 cursorPoint += cursorTarget->GetPosition();
 #endif
         }
-        
+
         return cursorTarget != NULL;
     }
 }
@@ -1534,14 +2955,14 @@ void wxWidgetCocoaImpl::keyEvent(WX_NSEvent event, WXWidget slf, void *_cmd)
 
     if ( [event type] == NSKeyDown )
     {
-        // there are key equivalents that are not command-combos and therefore not handled by cocoa automatically, 
+        // there are key equivalents that are not command-combos and therefore not handled by cocoa automatically,
         // therefore we call the menubar directly here, exit if the menu is handling the shortcut
         if ( [[[NSApplication sharedApplication] mainMenu] performKeyEquivalent:event] )
             return;
-    
+
         m_lastKeyDownEvent = event;
     }
-    
+
     if ( GetFocusedViewInWindow([slf window]) != slf || m_hasEditor || !DoHandleKeyEvent(event) )
     {
         wxOSX_EventHandlerPtr superimpl = (wxOSX_EventHandlerPtr) [[slf superclass] instanceMethodForSelector:(SEL)_cmd];
@@ -2172,10 +3593,10 @@ void wxWidgetCocoaImpl::doCommandBySelector(void* sel, WXWidget slf, void* _cmd)
 bool wxWidgetCocoaImpl::performKeyEquivalent(WX_NSEvent event, WXWidget slf, void *_cmd)
 {
     bool handled = false;
-    
+
     wxKeyEvent wxevent(wxEVT_KEY_DOWN);
     SetupKeyEvent( wxevent, event );
-   
+
     // because performKeyEquivalent is going up the entire view hierarchy, we don't have to
     // walk up the ancestors ourselves but let cocoa do it
 #if wxUSE_ACCEL
@@ -2183,11 +3604,11 @@ bool wxWidgetCocoaImpl::performKeyEquivalent(WX_NSEvent event, WXWidget slf, voi
     if (command != -1)
     {
         wxEvtHandler * const handler = m_wxPeer->GetEventHandler();
-        
+
         wxCommandEvent command_event( wxEVT_MENU, command );
         command_event.SetEventObject( wxevent.GetEventObject() );
         handled = handler->ProcessEvent( command_event );
-        
+
         if ( !handled )
         {
             // accelerators can also be used with buttons, try them too
@@ -2230,7 +3651,7 @@ bool wxWidgetCocoaImpl::resignFirstResponder(WXWidget slf, void *_cmd)
 {
     wxOSX_FocusHandlerPtr superimpl = (wxOSX_FocusHandlerPtr) [[slf superclass] instanceMethodForSelector:(SEL)_cmd];
     BOOL r = superimpl(slf, (SEL)_cmd);
-    
+
     // wxNSTextFields and wxNSComboBoxes have an editor as real responder, therefore they get
     // a resign notification when their editor takes over, don't trigger  event here, the control
     // gets a controlTextDidEndEditing notification which will send a focus kill.
@@ -2254,7 +3675,7 @@ bool wxWidgetCocoaImpl::isFlipped(WXWidget slf, void *WXUNUSED(_cmd))
 void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
 {
     // preparing the update region
-    
+
     wxRegion updateRgn;
 
     // since adding many rects to a region is a costly process, by default use the bounding rect
@@ -2269,7 +3690,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
 #else
     updateRgn.Union(wxFromNSRect(slf,*(NSRect*)rect));
 #endif
-    
+
     wxWindow* wxpeer = GetWXPeer();
 
     if ( wxpeer->MacGetLeftBorderSize() != 0 || wxpeer->MacGetTopBorderSize() != 0 )
@@ -2277,7 +3698,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
         // as this update region is in native window locals we must adapt it to wx window local
         updateRgn.Offset( wxpeer->MacGetLeftBorderSize() , wxpeer->MacGetTopBorderSize() );
     }
-    
+
     // Restrict the update region to the shape of the window, if any, and also
     // remember the region that we need to clear later.
     wxNonOwnedWindow* const tlwParent = wxpeer->MacGetTopLevelWindow();
@@ -2304,7 +3725,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             }
         }
     }
-    
+
     wxpeer->GetUpdateRegion() = updateRgn;
 
     // setting up the drawing context
@@ -2314,7 +3735,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
     if ( context != NULL )
     {
         CGContextSaveGState( context );
-        
+
 #if OSX_DEBUG_DRAWING
         CGContextBeginPath( context );
         CGContextMoveToPoint(context, 0, 0);
@@ -2329,7 +3750,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
         CGContextClosePath( context );
         CGContextStrokePath(context);
 #endif
-        
+
         if ( ![slf isFlipped] )
         {
             CGContextTranslateCTM( context, 0,  [m_osxView bounds].size.height );
@@ -2343,20 +3764,44 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
         CGContextRestoreGState( context );
         CGContextSaveGState( context );
     }
-    
+
     if ( !handled )
     {
         // call super
         SEL _cmd = @selector(drawRect:);
         wxOSX_DrawRectHandlerPtr superimpl = (wxOSX_DrawRectHandlerPtr) [[slf superclass] instanceMethodForSelector:_cmd];
-        superimpl(slf, _cmd, *(NSRect*)rect);
-        if ( context != NULL )
+
+        wxWindow *peer = GetWXPeer();
+        bool hasFocus = peer->HasFocus();
+        if (hasFocus && peer->NeedsFocusRing())
         {
-            CGContextRestoreGState( context );
-            CGContextSaveGState( context );
+           superimpl(slf, _cmd, *(NSRect*)rect);
+
+           // Paint it again, without text, causing focus halo to be
+           // superimposed about all else
+           if ( context != NULL )
+           {
+              HIThemeBeginFocus( context, kHIThemeFocusRingOnly, NULL );
+              CGContextSetTextDrawingMode( context, kCGTextInvisible );
+              superimpl(slf, _cmd, *(NSRect*)rect);
+              HIThemeEndFocus( context );
+
+              CGContextRestoreGState( context );
+              CGContextSaveGState( context );
+            }
+        }
+        else
+        {
+           superimpl(slf, _cmd, *(NSRect*)rect);
+
+           if ( context != NULL )
+           {
+               CGContextRestoreGState( context );
+               CGContextSaveGState( context );
+           }
         }
     }
-    
+
     if ( context != NULL )
     {
         // as we called restore above, we have to flip again if necessary
@@ -2365,7 +3810,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             CGContextTranslateCTM( context, 0,  [m_osxView bounds].size.height );
             CGContextScaleCTM( context, 1, -1 );
         }
-        
+
         if ( isTopLevel )
         {
             // We also need to explicitly draw the part of the top level window
@@ -2379,7 +3824,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
                 dc.SetDeviceClippingRegion(clearRgn);
                 dc.Clear();
             }
-            
+
 #if wxUSE_GRAPHICS_CONTEXT
             // If the window shape is defined by a path, stroke the path to show
             // the window border.
@@ -2393,7 +3838,7 @@ void wxWidgetCocoaImpl::drawRect(void* rect, WXWidget slf, void *WXUNUSED(_cmd))
             }
 #endif // wxUSE_GRAPHICS_CONTEXT
         }
-        
+
         wxpeer->MacPaintChildrenBorders();
         CGContextRestoreGState( context );
     }
@@ -2417,7 +3862,7 @@ void wxWidgetCocoaImpl::controlDoubleAction( WXWidget WXUNUSED(slf), void *WXUNU
 void wxWidgetCocoaImpl::controlTextDidChange()
 {
     wxWindow* wxpeer = (wxWindow*)GetWXPeer();
-    if ( wxpeer ) 
+    if ( wxpeer )
     {
         // since native rtti doesn't have to be enabled and wx' rtti is not aware of the mixin wxTextEntry, workaround is needed
         wxTextCtrl *tc = wxDynamicCast( wxpeer , wxTextCtrl );
@@ -2426,7 +3871,7 @@ void wxWidgetCocoaImpl::controlTextDidChange()
             tc->SendTextUpdatedEventIfAllowed();
         else if ( cb )
             cb->SendTextUpdatedEventIfAllowed();
-        else 
+        else
         {
             wxFAIL_MSG("Unexpected class for controlTextDidChange event");
         }
@@ -2447,6 +3892,435 @@ void wxWidgetCocoaImpl::controlTextDidChange()
 
 #endif
 
+@implementation wxAccessibilityChild
+- (id)initWithAccessible: (wxAccessible*) accessible_
+                  andNumber: (NSInteger) number_
+{
+   self = [super init];
+   accessible = accessible_;
+   number = number_;
+   return self;
+}
+
++ (id)accessibilityChildWithAccessible: (wxAccessible*)accessible_
+                             andNumber: (NSInteger)number_;
+{
+   return [
+      [[wxAccessibilityChild alloc]
+          initWithAccessible: accessible_ andNumber: number_]
+      autorelease
+   ];
+}
+
+- (NSString*)stringValue
+{
+   // For debugging
+   return @"";
+}
+
+- (BOOL)isEqual:(id)object
+{
+   if ([object isMemberOfClass: [wxAccessibilityChild class]])
+   {
+      wxAccessibilityChild *other = (wxAccessibilityChild*)object;
+      if (accessible == other->accessible && number == other->number)
+         return YES;
+   }
+   return NO;
+}
+
+// Implement the NSObject (NSAccessibility) informal protocol with appropriate
+// forwards to the wxAccessible object
+
+/* Attribute methods
+ */
+- (NSArray *)accessibilityAttributeNames
+{
+   return findAttributeNames( self, *accessible, number, NULL );
+}
+
+- (id)accessibilityAttributeValue:(NSString *)attribute
+{
+   const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+      return pAttribute->Get(self, *accessible, number);
+   return [super accessibilityAttributeValue: attribute];
+}
+
+- (BOOL)accessibilityIsAttributeSettable:(NSString *)attribute
+{
+   const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+      return pAttribute->IsSettable(self, *accessible, number);
+   return [super accessibilityIsAttributeSettable: attribute];
+}
+
+- (void)accessibilitySetValue:(id)value forAttribute:(NSString *)attribute
+{
+   const wxNSAccessibilityAttribute *pAttribute =
+      findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+   {
+      if (pAttribute->IsSettable(self, *accessible, number))
+         pAttribute->Set(self, *accessible, number, value);
+      return;
+   }
+
+   [super accessibilitySetValue: value forAttribute: attribute];
+}
+
+/* Parameterized Attribute methods
+ */
+- (NSArray *)accessibilityParameterizedAttributeNames
+{
+   return [super accessibilityParameterizedAttributeNames];
+}
+
+- (id)accessibilityAttributeValue:(NSString *)attribute forParameter:(id)parameter
+{
+   return [super accessibilityAttributeValue: attribute forParameter: parameter];
+}
+
+/* Acessibility action methods
+ */
+- (NSArray *)accessibilityActionNames
+{
+   // see comments in wxOSX_accessibilityActionNames
+   wxString unused;
+   wxAccStatus status = accessible->GetDefaultAction(number, &unused);
+   if (status == wxACC_OK)
+   {
+      return [NSArray arrayWithObject: NSAccessibilityPressAction];
+   }
+
+   if ([[self superclass] instancesRespondToSelector:
+        @selector(accessibilityActionNames)])
+      return [super accessibilityActionNames];
+   return [NSArray array];
+}
+
+- (NSString *)accessibilityActionDescription:(NSString *)action
+{
+   NSString *result = NSAccessibilityActionDescription(action);
+   if (result)
+      return result;
+
+   return [super accessibilityActionDescription: action];
+}
+
+- (void)accessibilityPerformAction:(NSString *)action
+{
+   wxAccStatus status = accessible->DoDefaultAction(number);
+   if (status == wxACC_OK)
+      return;
+
+   [super accessibilityPerformAction: action];
+}
+
+/* Return YES if the UIElement doesn't show up to the outside world - i.e. its parent should return the UIElement's children as its own - cutting the UIElement out. E.g. NSControls are ignored when they are single-celled.
+ */
+- (BOOL)accessibilityIsIgnored
+{
+   return NO;
+}
+
+/* Returns the deepest descendant of the UIElement hierarchy that contains the point. You can assume the point has already been determined to lie within the receiver. Override this method to do deeper hit testing within a UIElement - e.g. a NSMatrix would test its cells. The point is bottom-left relative screen coordinates.
+ */
+- (id)accessibilityHitTest:(NSPoint)point
+{
+   return [super accessibilityHitTest: point];
+}
+
+/* Returns the UI Element that has the focus. You can assume that the search for the focus has already been narrowed down to the reciever. Override this method to do a deeper search with a UIElement - e.g. a NSMatrix would determine if one of its cells has the focus.
+ */
+- (id)accessibilityFocusedUIElement
+{
+   return [super accessibilityFocusedUIElement];
+}
+
+
+/*  Optional methods to improve performance of accessible objects with large numbers of children or large numbers of UI Elements returned from attributes that return an array (selected children, or visible children, for instance).  The default implementation for these operations will call -accessibilityAttributeValue: to retrieve the entire array of values, and then perform the appropriate operation.  If these methods are implemented, they will be used instead.  For accessibility objects with many children, the results to these methods can sometimes be calculated without generating the entire array of children which can improve performance.
+ */
+
+/* Given an accessibility child of an object, return the index of that child in the parent.
+ */
+- (NSUInteger)accessibilityIndexOfChild:(id)child
+{
+   return swxNSAccessibilityChildrenAttribute
+      .IndexOfValue(self, *accessible, number, child);
+}
+
+/* Return the count of an accessibility array attribute.
+ */
+- (NSUInteger)accessibilityArrayAttributeCount:(NSString *)attribute
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   const wxNSAccessibilityAttribute *pAttribute =
+   findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+   {
+      const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+         dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+      if (pArrayAttribute)
+      {
+         return pArrayAttribute->GetCount(self, *accessible, number);
+      }
+   }
+
+   return [super accessibilityArrayAttributeCount: attribute];
+}
+
+/* Return a subarray of values of an accessibility array attribute.  Note this method does not take a range.  The max count is the maximum desired number of items requested by an accessibility client.  This number may be beyond the bounds of your array.
+ */
+- (NSArray *)accessibilityArrayAttributeValues:(NSString *)attribute
+                                         index:(NSUInteger)index
+                                      maxCount:(NSUInteger)maxCount
+{
+   // If attribute is defined for the wxAccessible object, that takes precedence
+   const wxNSAccessibilityAttribute *pAttribute =
+   findAttribute(self, attribute);
+   if (pAttribute && pAttribute->IsPresent(self, *accessible, number))
+   {
+      const wxNSAccessibilityArrayAttribute *pArrayAttribute =
+      dynamic_cast<const wxNSAccessibilityArrayAttribute*>(pAttribute);
+      if (pArrayAttribute)
+      {
+         return pArrayAttribute->GetValues
+            (self, *accessible, number, index, maxCount);
+      }
+   }
+
+   return [super accessibilityArrayAttributeValues: attribute
+                                             index: index
+                                          maxCount: maxCount];
+}
+
+@end
+
+void wxOSXCocoaClassAddWXAccessibilityMethods(Class c)
+{
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityAttributeNames), (IMP) wxOSX_accessibilityAttributeNames, "@@:" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityAttributeValue:), (IMP) wxOSX_accessibilityAttributeValue, "@@:@" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityIsAttributeSettable:), (IMP) wxOSX_accessibilityIsAttributeSettable, "c@:@" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilitySetValue:forAttribute:), (IMP) wxOSX_accessibilitySetValue_forAttribute, "v@:@@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityParameterizedAttributeNames), (IMP) wxOSX_accessibilityParameterizedAttributeNames, "@@:" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityAttributeValue:forParameter:), (IMP) wxOSX_accessibilityAttributeValue_forParameter, "@@:@@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityActionNames), (IMP) wxOSX_accessibilityActionNames, "@@:" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityActionDescription:), (IMP) wxOSX_accessibilityActionDescription, "@@:@" )
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityPerformAction:), (IMP) wxOSX_accessibilityPerformAction, "v@:@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityIsIgnored), (IMP) wxOSX_accessibilityIsIgnored, "c@:" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityHitTest:), (IMP) wxOSX_accessibilityHitTest, "@@:{_NSPoint=ff}" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityFocusedUIElement), (IMP) wxOSX_accessibilityFocusedUIElement, "@@:" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityIndexOfChild:), (IMP) wxOSX_accessibilityIndexOfChild, "I@:@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityArrayAttributeCount:), (IMP) wxOSX_accessibilityArrayAttributeCount, "I@:@" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilityArrayAttributeValues:index:maxCount:), (IMP) wxOSX_accessibilityArrayAttributeValues_index_maxCount, "@@:@II" )
+
+   wxOSX_CLASS_ADD_METHOD(c, @selector(accessibilitySetOverrideValue:forAttribute:), (IMP) wxOSX_accessibilitySetOverrideValue_forAttribute, "c@:@@" )
+}
+
+// static
+void wxAccessible::NotifyEvent
+(int eventType, wxWindow* window, wxAccObject objectType, int objectId)
+{
+#if 0
+   // Leftover NSAccessibility notifications that didn't correspond
+
+   /* Focus notifications
+    */
+NSAccessibilityMainWindowChangedNotification;
+
+   /* Application notifications
+    */
+NSAccessibilityApplicationActivatedNotification;
+NSAccessibilityApplicationDeactivatedNotification;
+NSAccessibilityApplicationHiddenNotification;
+NSAccessibilityApplicationShownNotification;
+
+   /* Window notifications
+    */
+NSAccessibilityWindowCreatedNotification;
+NSAccessibilityWindowDeminiaturizedNotification;
+
+   /* Drawer & sheet notifications
+    */
+NSAccessibilityDrawerCreatedNotification;
+NSAccessibilitySheetCreatedNotification;
+
+   /* Misc notifications
+    */
+NSAccessibilityHelpTagCreatedNotification	;
+NSAccessibilityRowCountChangedNotification;
+
+NSAccessibilityRowExpandedNotification	;
+NSAccessibilityRowCollapsedNotification	;
+
+   /* Cell-table notifications
+    */
+
+   /* Layout area notifications
+    */
+NSAccessibilityUnitsChangedNotification ;
+
+#endif
+
+   enum { maxNotifications = 6 };
+   NSString *notifications[maxNotifications];
+   for(unsigned ii = 0; ii < maxNotifications; ++ii)
+      notifications[ii] = NULL;
+
+   NSString *& notification = notifications[0];
+   NSString *& notification2 = notifications[1];
+
+   switch (eventType)
+   {
+      case wxACC_EVENT_SYSTEM_MOVESIZEEND:
+         notification = NSAccessibilityWindowResizedNotification;
+         break;
+
+      case wxACC_EVENT_SYSTEM_MINIMIZEEND:
+         notification = NSAccessibilityWindowMiniaturizedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_CREATE:
+         notification = NSAccessibilityCreatedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_DESTROY:
+         notification = NSAccessibilityUIElementDestroyedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_NAMECHANGE:
+         notification = NSAccessibilityTitleChangedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_VALUECHANGE:
+         notification = NSAccessibilityValueChangedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_LOCATIONCHANGE:
+         notification = NSAccessibilityMovedNotification;
+         notification2 = NSAccessibilityResizedNotification;
+         break;
+
+      case wxACC_EVENT_SYSTEM_DRAGDROPEND:
+         // Not sure if this is right...
+         if (objectType == wxOBJID_WINDOW)
+            notification = NSAccessibilityWindowMovedNotification;
+         else
+            notification = NSAccessibilityMovedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_FOCUS:
+         // Not sure if this is right...
+         if (objectType == wxOBJID_WINDOW)
+            notification = NSAccessibilityFocusedWindowChangedNotification;
+         else
+            notification = NSAccessibilityFocusedUIElementChangedNotification;
+         break;
+
+         // Selection notifications... quite a mismatch between the
+         // wxWidgets interface and the NS interface.  Just make lots
+         // of notifications to cover the possibilities.
+      case wxACC_EVENT_OBJECT_SELECTION:
+      case wxACC_EVENT_OBJECT_SELECTIONADD:
+      case wxACC_EVENT_OBJECT_SELECTIONREMOVE:
+      case wxACC_EVENT_OBJECT_SELECTIONWITHIN:
+         notifications[0] = NSAccessibilitySelectedTextChangedNotification;
+         notifications[1] = NSAccessibilitySelectedChildrenChangedNotification;
+         notifications[2] = NSAccessibilitySelectedRowsChangedNotification;
+         notifications[3] = NSAccessibilitySelectedColumnsChangedNotification;
+         notifications[4] = NSAccessibilitySelectedCellsChangedNotification;
+         // notifications[5] = NSAccessibilitySelectedChildrenMovedNotification;
+         break;
+
+      case wxACC_EVENT_OBJECT_REORDER:
+      case wxACC_EVENT_SYSTEM_SCROLLINGEND:
+         notification = NSAccessibilitySelectedChildrenMovedNotification;
+         // maybe?
+         break;
+
+      case wxACC_EVENT_OBJECT_STATECHANGE:
+      case wxACC_EVENT_OBJECT_DESCRIPTIONCHANGE:
+      case wxACC_EVENT_OBJECT_PARENTCHANGE:
+      case wxACC_EVENT_OBJECT_HELPCHANGE:
+      case wxACC_EVENT_OBJECT_DEFACTIONCHANGE:
+      case wxACC_EVENT_OBJECT_ACCELERATORCHANGE:
+         if (objectType == wxOBJID_CLIENT)
+         {
+            notification = NSAccessibilitySelectedChildrenChangedNotification;
+            // maybe?
+            break;
+         }
+         else
+            return;
+
+      case wxACC_EVENT_SYSTEM_SOUND:
+      case wxACC_EVENT_SYSTEM_ALERT:
+      case wxACC_EVENT_SYSTEM_FOREGROUND:
+      case wxACC_EVENT_SYSTEM_MENUSTART:
+      case wxACC_EVENT_SYSTEM_MENUEND:
+      case wxACC_EVENT_SYSTEM_MENUPOPUPSTART:
+      case wxACC_EVENT_SYSTEM_MENUPOPUPEND:
+      case wxACC_EVENT_SYSTEM_CAPTURESTART:
+      case wxACC_EVENT_SYSTEM_CAPTUREEND:
+      case wxACC_EVENT_SYSTEM_MOVESIZESTART:
+
+      case wxACC_EVENT_SYSTEM_CONTEXTHELPSTART:
+      case wxACC_EVENT_SYSTEM_CONTEXTHELPEND:
+      case wxACC_EVENT_SYSTEM_DRAGDROPSTART:
+
+      case wxACC_EVENT_SYSTEM_DIALOGSTART:
+      case wxACC_EVENT_SYSTEM_DIALOGEND:
+      case wxACC_EVENT_SYSTEM_SCROLLINGSTART:
+
+      case wxACC_EVENT_SYSTEM_SWITCHSTART:
+      case wxACC_EVENT_SYSTEM_SWITCHEND:
+      case wxACC_EVENT_SYSTEM_MINIMIZESTART:
+
+      case wxACC_EVENT_OBJECT_SHOW:
+      case wxACC_EVENT_OBJECT_HIDE:
+
+      default:
+         // no equivalents
+      return;
+   }
+
+   id element = nil;
+   if (objectType == wxOBJID_CLIENT)
+   {
+      wxAccessible *pAccessible = window->GetAccessible();
+      if (!pAccessible)
+         return;
+
+      wxAccessible *child = NULL;
+      wxAccStatus status = pAccessible->GetChild(objectId, &child);
+      element = GetUIElement(*pAccessible, objectId, child);
+   }
+   else
+      element = window->GetPeer()->GetWXWidget();
+
+   if (!element)
+      return;
+
+   for(unsigned ii = 0; ii < maxNotifications; ++ii)
+   {
+      NSString *notification = notifications[ii];
+      if (!notification)
+         break;
+      NSAccessibilityPostNotification(element, notification);
+   }
+}
+
 void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
 {
 
@@ -2455,6 +4329,8 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
     {
 #endif
 
+    wxOSX_CLASS_ADD_METHOD(c, @selector(stringValue), (IMP) wxOSX_stringValue, "@@:");
+
     wxOSX_CLASS_ADD_METHOD(c, @selector(mouseDown:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(rightMouseDown:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(otherMouseDown:), (IMP) wxOSX_mouseEvent, "v@:@" )
@@ -2468,7 +4344,7 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
     wxOSX_CLASS_ADD_METHOD(c, @selector(mouseDragged:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(rightMouseDragged:), (IMP) wxOSX_mouseEvent, "v@:@" )
     wxOSX_CLASS_ADD_METHOD(c, @selector(otherMouseDragged:), (IMP) wxOSX_mouseEvent, "v@:@" )
-    
+
     wxOSX_CLASS_ADD_METHOD(c, @selector(acceptsFirstMouse:), (IMP) wxOSX_acceptsFirstMouse, "v@:@" )
 
     wxOSX_CLASS_ADD_METHOD(c, @selector(scrollWheel:), (IMP) wxOSX_mouseEvent, "v@:@" )
@@ -2494,7 +4370,7 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
 #if !wxOSX_USE_NATIVE_FLIPPED
     wxOSX_CLASS_ADD_METHOD(c, @selector(isFlipped), (IMP) wxOSX_isFlipped, "c@:" )
 #endif
-        
+
     if ( !(skipFlags & wxOSXSKIP_DRAW) )
         wxOSX_CLASS_ADD_METHOD(c, @selector(drawRect:), (IMP) wxOSX_drawRect, "v@:{_NSRect={_NSPoint=ff}{_NSSize=ff}}" )
 
@@ -2508,6 +4384,8 @@ void wxOSXCocoaClassAddWXMethods(Class c, wxOSXSkipOverrides skipFlags)
     wxOSX_CLASS_ADD_METHOD(c, @selector(performDragOperation:), (IMP) wxOSX_performDragOperation, "c@:@" )
 #endif
 
+    wxOSXCocoaClassAddWXAccessibilityMethods(c);
+
 #if OBJC_API_VERSION < 2
     } ;
     static int method_count = WXSIZEOF( wxmethods );
@@ -2534,11 +4412,11 @@ wxWidgetImpl( peer, flags )
 {
     Init();
     m_osxView = w;
-    
+
     // check if the user wants to create the control initially hidden
     if ( !peer->IsShown() )
         SetVisibility(false);
-    
+
     // gc aware handling
     if ( m_osxView )
         CFRetain(m_osxView);
@@ -2565,7 +4443,7 @@ wxWidgetCocoaImpl::~wxWidgetCocoaImpl()
 {
     if ( GetWXPeer() && GetWXPeer()->IsFrozen() )
         SetDrawingEnabled(true);
-    
+
     RemoveAssociations( this );
 
     if ( !IsRootControl() )
@@ -2591,7 +4469,7 @@ bool wxWidgetCocoaImpl::IsVisible() const
 void wxWidgetCocoaImpl::SetVisibility( bool visible )
 {
     [m_osxView setHidden:(visible ? NO:YES)];
-    
+
     // trigger redraw upon shown for layer-backed views
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_14
     if ( WX_IS_MACOS_AVAILABLE(10, 14 ) )
@@ -3001,7 +4879,7 @@ void wxWidgetCocoaImpl::GetPosition( int &x, int &y ) const
     wxRect r = wxFromNSRect( [m_osxView superview], [m_osxView frame] );
     x = r.GetLeft();
     y = r.GetTop();
-    
+
     // under Cocoa we might have a contentView in the wxParent to which we have to
     // adjust the coordinates
     wxWindowMac* parent = GetWXPeer()->GetParent();
@@ -3052,7 +4930,7 @@ void wxWidgetCocoaImpl::GetContentArea( int&left, int &top, int &width, int &hei
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_14
 namespace
 {
-    
+
 void SetSubviewsNeedDisplay( NSView *view )
 {
     for ( NSView *sub in view.subviews )
@@ -3064,7 +4942,7 @@ void SetSubviewsNeedDisplay( NSView *view )
         SetSubviewsNeedDisplay(sub);
     }
 }
-    
+
 }
 #endif
 
@@ -3123,12 +5001,12 @@ bool wxWidgetCocoaImpl::SetFocus()
 void wxWidgetCocoaImpl::SetDropTarget(wxDropTarget* target)
 {
     [m_osxView unregisterDraggedTypes];
-    
+
     if ( target == NULL )
         return;
-    
+
     wxDataObject* dobj = target->GetDataObject();
-    
+
     if( dobj )
     {
         CFMutableArrayRef typesarray = CFArrayCreateMutable(kCFAllocatorDefault,0,&kCFTypeArrayCallBacks);
@@ -3157,7 +5035,7 @@ void wxWidgetCocoaImpl::Embed( wxWidgetImpl *parent )
     NSView* container = parent->GetWXWidget() ;
     wxASSERT_MSG( container != NULL , wxT("No valid mac container control") ) ;
     [container addSubview:m_osxView];
-    
+
     // User panes will be frozen elsewhere
     if( m_wxPeer->IsFrozen() && !IsUserPane() )
         SetDrawingEnabled(false);
@@ -3185,14 +5063,14 @@ void wxWidgetCocoaImpl::SetBackgroundColour( const wxColour &col )
 bool wxWidgetCocoaImpl::SetBackgroundStyle( wxBackgroundStyle style )
 {
     BOOL opaque = ( style == wxBG_STYLE_PAINT );
-    
+
     if ( [m_osxView respondsToSelector:@selector(setOpaque:) ] )
     {
         [m_osxView setOpaque: opaque];
         if ( style == wxBG_STYLE_TRANSPARENT )
             [m_osxView setBackgroundColor:[NSColor clearColor]];
     }
-    
+
     return true ;
 }
 
@@ -3248,7 +5126,7 @@ void wxWidgetCocoaImpl::SetLabel( const wxString& title, wxFontEncoding encoding
             [attrString endEditing];
 
             [(id)m_osxView setAttributedTitle:attrString];
-            
+
             [attrString release];
 
             return;
@@ -3479,7 +5357,7 @@ void wxWidgetCocoaImpl::SetControlSize( wxWindowVariant variant )
     if ( [m_osxView isKindOfClass:[NSScrollView class] ] )
     {
         NSView* targetView = [(NSScrollView*) m_osxView documentView];
-    
+
         if ( [targetView respondsToSelector:@selector(setControlSize:)] )
             [targetView setControlSize:size];
         else if ([targetView respondsToSelector:@selector(cell)])
@@ -3514,7 +5392,7 @@ void wxWidgetCocoaImpl::SetToolTip(wxToolTip* tooltip)
         wxCFStringRef cf( tooltip->GetTip() , m_wxPeer->GetFont().GetEncoding() );
         [m_osxView setToolTip: cf.AsNSString()];
     }
-    else 
+    else
     {
         [m_osxView setToolTip:nil];
     }
@@ -3533,7 +5411,7 @@ void wxWidgetCocoaImpl::InstallEventHandler( WXWidget control )
         }
         else
             [c setAction: @selector(controlAction:)];
-        
+
         if ([c respondsToSelector:@selector(setDoubleAction:)])
         {
             [c setDoubleAction: @selector(controlDoubleAction:)];
@@ -3571,7 +5449,7 @@ bool wxWidgetCocoaImpl::EnableTouchEvents(int eventsMask)
                     new wxCocoaGesturesImpl(this, m_osxView, eventsMask)
                 );
 #endif
-                
+
                 [m_osxView setAcceptsTouchEvents:YES];
             }
 
@@ -3597,12 +5475,12 @@ bool wxWidgetCocoaImpl::DoHandleCharEvent(NSEvent *event, NSString *text)
               ++it )
         {
             wxKeyEvent wxevent(wxEVT_CHAR);
-            
+
             // if we have exactly one character resulting from the event, then
             // set the corresponding modifiers and raw data from the nsevent
             // otherwise leave these at defaults, as they probably would be incorrect
             // anyway (IME input)
-            
+
             if ( event != nil && length == 1)
             {
                 SetupKeyEvent(wxevent,event,text);
@@ -3618,14 +5496,14 @@ bool wxWidgetCocoaImpl::DoHandleCharEvent(NSEvent *event, NSString *text)
                 wxevent.m_uniChar = aunichar;
 #endif
                 wxevent.m_keyCode = aunichar < 0x80 ? aunichar : WXK_NONE;
-                
+
                 wxevent.SetEventObject(peer);
                 wxevent.SetId(peer->GetId());
 
                 if ( event )
                     wxevent.SetTimestamp( (int)([event timestamp] * 1000) ) ;
             }
-            
+
             result = peer->OSXHandleKeyEvent(wxevent) || result;
         }
     }
@@ -3722,7 +5600,7 @@ void wxWidgetCocoaImpl::DoNotifyFocusSet()
     NSResponder* responder = wxNonOwnedWindowCocoaImpl::GetFormerFirstResponder();
     NSView* otherView = wxOSXGetViewFromResponder(responder);
     wxWidgetImpl* otherWindow = FindFromWXWidget(otherView);
-    
+
     // It doesn't make sense to notify about the focus set if it's the same
     // control in the end, and just a different subview
     if ( otherWindow != this )
@@ -3734,7 +5612,7 @@ void wxWidgetCocoaImpl::DoNotifyFocusLost()
     NSResponder * responder = wxNonOwnedWindowCocoaImpl::GetNextFirstResponder();
     NSView* otherView = wxOSXGetViewFromResponder(responder);
     wxWidgetImpl* otherWindow = FindBestFromWXWidget(otherView);
-    
+
     // It doesn't make sense to notify about the loss of focus if it's the same
     // control in the end, and just a different subview
     if ( otherWindow != this )
@@ -3790,8 +5668,8 @@ void wxWidgetCocoaImpl::SetCursor(const wxCursor& cursor)
         NSRect location = NSZeroRect;
         location.origin = [NSEvent mouseLocation];
         location = [[m_osxView window] convertRectFromScreen:location];
-        NSPoint locationInView = [m_osxView convertPoint:location.origin fromView:nil];        
-        
+        NSPoint locationInView = [m_osxView convertPoint:location.origin fromView:nil];
+
         if( NSMouseInRect(locationInView, [m_osxView bounds], YES) )
         {
             [(NSCursor*)cursor.GetHCURSOR() set];
@@ -3853,7 +5731,7 @@ wxWidgetImpl* wxWidgetImpl::CreateUserPane( wxWindowMac* wxpeer, wxWindowMac* WX
 wxWidgetImpl* wxWidgetImpl::CreateContentView( wxNonOwnedWindow* now )
 {
     NSWindow* tlw = now->GetWXWindow();
-    
+
     wxWidgetCocoaImpl* c = NULL;
     if ( now->IsNativeWindowWrapper() )
     {
diff --git tests/controls/gridtest.cpp tests/controls/gridtest.cpp
index abc11a8803..6392bbaefe 100644
--- tests/controls/gridtest.cpp
+++ tests/controls/gridtest.cpp
@@ -56,6 +56,9 @@ private:
         NONGTK_TEST( RangeSelect );
         CPPUNIT_TEST( Cursor );
         CPPUNIT_TEST( Selection );
+        CPPUNIT_TEST( ScrollWhenSelect );
+        WXUISIM_TEST( MoveGridCursorUsingEndKey );
+        WXUISIM_TEST( SelectUsingEndKey );
         CPPUNIT_TEST( AddRowCol );
         CPPUNIT_TEST( ColumnOrder );
         CPPUNIT_TEST( ColumnVisibility );
@@ -85,6 +88,9 @@ private:
     void RangeSelect();
     void Cursor();
     void Selection();
+    void ScrollWhenSelect();
+    void MoveGridCursorUsingEndKey();
+    void SelectUsingEndKey();
     void AddRowCol();
     void ColumnOrder();
     void ColumnVisibility();
@@ -477,6 +483,92 @@ void GridTestCase::Selection()
     CPPUNIT_ASSERT(!m_grid->IsInSelection(3, 0));
 }
 
+void GridTestCase::ScrollWhenSelect()
+{
+    m_grid->AppendCols(10);
+
+    REQUIRE( m_grid->GetGridCursorCol() == 0 );
+    REQUIRE( m_grid->GetGridCursorRow() == 0 );
+    REQUIRE( m_grid->IsVisible(0, 0) );
+    REQUIRE( !m_grid->IsVisible(0, 4) );
+
+    for ( int i = 0; i < 4; ++i )
+    {
+        m_grid->MoveCursorRight(true);
+    }
+    CHECK( m_grid->IsVisible(0, 4) );
+
+    m_grid->ClearSelection();
+    m_grid->SetGridCursor(1, 1);
+    for ( int i = 0; i < 5; ++i )
+    {
+        m_grid->MoveCursorDown(true);
+    }
+    CHECK( m_grid->IsVisible(6, 1) );
+}
+
+void GridTestCase::MoveGridCursorUsingEndKey()
+{
+#if wxUSE_UIACTIONSIMULATOR
+    wxUIActionSimulator sim;
+
+    m_grid->AppendCols(10);
+
+    REQUIRE( m_grid->GetGridCursorCol() == 0 );
+    REQUIRE( m_grid->GetGridCursorRow() == 0 );
+    REQUIRE( m_grid->IsVisible(0, 0) );
+
+    // Hide the last row.
+    m_grid->HideRow(9);
+    // Hide the last column.
+    m_grid->HideCol(11);
+    // Move the penult column.
+    m_grid->SetColPos(10, 5);
+
+    m_grid->SetFocus();
+
+    sim.KeyDown(WXK_END, wxMOD_CONTROL);
+    sim.KeyUp(WXK_END, wxMOD_CONTROL);
+    wxYield();
+
+    CHECK( m_grid->GetGridCursorRow() == 8 );
+    CHECK( m_grid->GetGridCursorCol() == 9 );
+    CHECK( m_grid->IsVisible(8, 9) );
+#endif
+}
+
+void GridTestCase::SelectUsingEndKey()
+{
+#if wxUSE_UIACTIONSIMULATOR
+    wxUIActionSimulator sim;
+
+    m_grid->AppendCols(10);
+
+    REQUIRE( m_grid->GetGridCursorCol() == 0 );
+    REQUIRE( m_grid->GetGridCursorRow() == 0 );
+    REQUIRE( m_grid->IsVisible(0, 0) );
+
+    m_grid->SetFocus();
+
+    sim.KeyDown(WXK_END, wxMOD_CONTROL | wxMOD_SHIFT);
+    sim.KeyUp(WXK_END, wxMOD_CONTROL | wxMOD_SHIFT);
+    wxYield();
+
+    wxGridCellCoordsArray topleft = m_grid->GetSelectionBlockTopLeft();
+    wxGridCellCoordsArray bottomright = m_grid->GetSelectionBlockBottomRight();
+
+    CHECK( topleft.Count() == 1 );
+    CHECK( bottomright.Count() == 1 );
+
+    CHECK( topleft.Item(0).GetCol() == 0 );
+    CHECK( topleft.Item(0).GetRow() == 0 );
+    CHECK( bottomright.Item(0).GetCol() == 11 );
+    CHECK( bottomright.Item(0).GetRow() == 9 );
+
+    CHECK( m_grid->IsVisible(8, 9) );
+#endif
+}
+
 void GridTestCase::AddRowCol()
 {
     CPPUNIT_ASSERT_EQUAL(10, m_grid->GetNumberRows());
